{% extends 'base.html' %}
{% load static %}

{% block content %}
<div id="combate-content" class="combate-detalhes-center" data-is-gm="{% if combate.sala.game_master == user %}true{% else %}false{% endif %}">
  <!-- Topo: info de turno + ações globais -->
  <div class="turno-topbar combate-card">
    <div class="turno-topbar-row">
      <div class="turno-topbar-info">
      {% if turno_ativo %}
        <strong>Turno:</strong> {{ turno_ativo.personagem.nome }}
      {% else %}
        <strong>Sem turno ativo</strong>
      {% endif %}
      </div>
      <div class="turno-topbar-actions">
      {% if not turno_ativo and combate.ativo %}
        <form method="post" action="{% url 'iniciar_turno' combate.id %}" class="inline-form">
          {% csrf_token %}
          <button type="submit" class="btn btn-sm">Iniciar Turno</button>
        </form>
      {% endif %}
      {% if turno_ativo %}
        <form method="post" action="{% url 'avancar_turno' combate.id %}" class="inline-form">
          {% csrf_token %}
          <button type="submit" formnovalidate class="btn btn-sm">Avançar Turno</button>
        </form>
      {% endif %}
      {% if combate.ativo and combate.sala.game_master == user %}
        <form method="post" action="{% url 'finalizar_combate' combate.id %}" class="inline-form">
          {% csrf_token %}
          <button type="submit" class="btn btn-sm btn-danger" formnovalidate>Finalizar Combate</button>
        </form>
      {% endif %}
      </div>
    </div>
  {# Moved map selection next to the map title in the right column #}
  </div>

  <!-- Grid 1/3 - 2/3 -->
  <div class="combate-layout-grid">
    <!-- Coluna esquerda: Ações + Histórico -->
  <div class="combate-col-left">

      <h3 class="combate-section-title">Ações de</h3>
      <div class="acao-top-row">
        <select id="personagem_acao" name="personagem_acao" form="form-ataque" class="select-md">
          {% if combate.sala.game_master == user %}
            {% for p in participantes %}
              <option value="{{ p.id }}" data-personagem-id="{{ p.personagem.id }}">{{ p.display_nome|default:p.personagem.nome }}</option>
            {% endfor %}
          {% else %}
            {% for p in participantes %}
              {% if p.personagem.usuario == user %}
                <option value="{{ p.id }}" data-personagem-id="{{ p.personagem.id }}">{{ p.display_nome|default:p.personagem.nome }}</option>
              {% endif %}
            {% endfor %}
          {% endif %}
        </select>
        <form method="post" action="{% url 'realizar_ataque' combate.id %}" id="form-d20" class="inline-form">
          {% csrf_token %}
          <input type="hidden" name="personagem_acao" id="personagem_acao_hidden_d20" value="{{ participantes.0.id }}">
          <button type="submit" name="rolar_d20" value="1" class="btn btn-sm">Rolar d20</button>
        </form>
      </div>

      <form method="post" action="{% url 'realizar_ataque' combate.id %}" id="form-ataque" class="combate-card ataque-card">
        {% csrf_token %}
  <input type="hidden" name="personagem_acao" id="personagem_acao_hidden" value="{{ participantes.0.id }}">
  <!-- Hidden extras para manter sincronização existente -->
  <input type="hidden" id="personagem_acao_hidden_pericia" value="{{ participantes.0.id }}">
  <input type="hidden" id="personagem_acao_hidden_caracteristica" value="{{ participantes.0.id }}">

  <label for="alvo">Alvo(s):</label>
        <small id="alvo_hint" class="form-hint" style="display:block; margin:-4px 0 6px; color:#666; font-size:12px;">
          Segure Ctrl (Windows/Linux) ou Cmd (macOS) para selecionar múltiplos; use Shift para selecionar intervalos.
        </small>
  <select id="alvo" name="alvo_id" multiple size="4" class="multiselect-alvos" aria-describedby="alvo_hint" title="Segure Ctrl (Windows/Linux) ou Cmd (macOS) para seleção múltipla; Shift para intervalos.">
          {% for p in participantes %}
            <option value="{{ p.id }}">{{ p.display_nome|default:p.personagem.nome }}</option>
          {% endfor %}
        </select>

        <div class="acao-row poder-row">
          <label for="poder">Poder:</label>
          <select name="poder_id" id="poder" required class="select-md" data-tipos="{}" aria-describedby="poder_hint">
            {% for poder in poderes_disponiveis %}
              <option value="{{ poder.id }}" data-tipo="{{ poder.tipo }}">{{ poder.nome }}</option>
            {% empty %}
              <option disabled>Nenhum poder disponível</option>
            {% endfor %}
          </select>
          <button type="submit" class="btn btn-sm" id="btn-rolar-poder">Rolar</button>
        </div>
        <small id="poder_hint" class="form-hint" style="display:block; margin:-4px 0 6px; color:#666; font-size:12px;"></small>

        <div class="acao-row">
          <label for="pericia_rolar">Perícia:</label>
          <select name="pericia" id="pericia_rolar" class="select-md">
            <option value="">-- Selecione uma perícia --</option>
            {% for pericia in pericias %}
              <option value="{{ pericia }}">{{ pericia|capfirst }}</option>
            {% endfor %}
          </select>
          <button type="submit" name="rolar_pericia" value="1" class="btn btn-sm" formnovalidate>Rolar</button>
        </div>

        <div class="acao-row">
          <label for="caracteristica_rolar">Característica:</label>
          <select name="caracteristica" id="caracteristica_rolar" class="select-md">
            <option value="">-- Selecione uma característica --</option>
            {% for c in caracteristicas %}
              <option value="{{ c }}">{{ c|capfirst }}</option>
            {% endfor %}
          </select>
          <button type="submit" name="rolar_caracteristica" value="1" class="btn btn-sm" formnovalidate>Rolar</button>
        </div>
      </form>

      

  <div class="mapa-header-row">
    <h3 class="combate-section-title" style="margin:0">Histórico de Ataques</h3>
    {% if combate.sala.game_master == user %}
    <div class="mapa-header-actions">
      <form method="post" action="{% url 'limpar_historico' combate.id %}" class="combate-inline-form form-limpar-historico" onsubmit="return confirm('Limpar todo o histórico de ataques? Esta ação não pode ser desfeita.');">
        {% csrf_token %}
        <button type="submit" class="btn btn-sm" formnovalidate>Limpar Histórico</button>
      </form>
    </div>
    {% endif %}
  </div>
  <div id="historico-card" class="combate-card">
  <ul class="turnos-list">
        {% for turno in turnos %}
          <li class="turno-item {% if turno.ativo %}ativo{% endif %}">
            <div class="turno-header">
              <strong>Rodada {{ turno.ordem }}</strong>
              <span class="turno-data">{{ turno.criado_em|date:"d/m/Y H:i" }}</span>
              {% if turno.ativo %}<span class="status-badge atual">Ativo</span>{% endif %}
            </div>
            <div class="turno-desc">{{ turno.descricao|safe }}</div>
          </li>
        {% empty %}
          <li class="turno-item vazio"><em>Nenhum ataque registrado ainda.</em></li>
        {% endfor %}
  </ul>
  </div>
    </div>

    <!-- Coluna direita: Mapa + Status participantes -->
    <div class="combate-col-right">
      <div class="mapa-header-row">
        <h3 class="combate-section-title" style="margin:0">Mapa do Combate</h3>
        {% if combate.sala.game_master == user %}
        <div class="mapa-header-actions">
          <label for="mapa_existente_top" class="sr-only">Selecionar mapa</label>
          <select id="mapa_existente_top" class="select-sm" title="Selecionar mapa">
            <option value="">– mapa –</option>
            {% for mapa in mapas_globais %}
              <option value="{{ mapa.id }}">{{ mapa.nome }}</option>
            {% endfor %}
          </select>
          <button type="button" id="btn-usar-mapa" class="btn btn-sm">Usar</button>
          <a href="{% url 'adicionar_mapa' combate.id %}" target="_blank" rel="noopener" id="btn-add-mapa-link" class="btn btn-sm">Novo</a>
          <!-- Grade opcional para precisão de movimento -->
          <label style="margin-left:8px; display:inline-flex; align-items:center; gap:4px;">
            <input type="checkbox" id="grid-enable"> Grade
          </label>
          <select id="grid-size" class="select-sm" title="Tamanho da grade" style="margin-left:4px;">
            <option value="20">20px</option>
            <option value="40" selected>40px</option>
            <option value="60">60px</option>
          </select>
        </div>
        {% endif %}
      </div>
      {% if combate.mapas.all %}
        {% for mapa in combate.mapas.all %}
          <div class="mapa-wrapper">
            <div id="mapa-area-{{ mapa.id }}" class="mapa-area" data-scale="1">
              <div class="mapa-canvas">
  <img src="{{ mapa.imagem.url }}" alt="{{ mapa.nome }}" class="mapa-img" title="{{ mapa.imagem.url }}" data-fallback="{% static 'img/mapa_placeholder.svg' %}" onerror="this.onerror=null;this.src=this.dataset.fallback;">
  {% if combate.sala.game_master == user %}
    <div class="mapa-debug-url" style="font-size:12px;color:#888;margin-top:4px;word-break:break-all;">URL: {{ mapa.imagem.url }}</div>
  {% endif %}
            {% for posicao in posicoes %}
              {% if posicao.mapa.id == mapa.id %}
                {% if posicao.participante.personagem.foto %}
         <img src="{{ posicao.participante.personagem.foto.url }}" title="{{ posicao.participante.personagem.foto.url }}"
           id="token-{{ posicao.id }}"
           class="mapa-token"
           style="left:{{ posicao.x }}px; top:{{ posicao.y }}px; width:{{ posicao.token_size|default:40 }}px; height:{{ posicao.token_size|default:40 }}px;"
           draggable="true"
           ondragstart="drag(event, {{ posicao.id }})">
                {% else %}
         <div id="token-{{ posicao.id }}" class="mapa-token token-fallback"
           style="left:{{ posicao.x }}px; top:{{ posicao.y }}px; width:{{ posicao.token_size|default:40 }}px; height:{{ posicao.token_size|default:40 }}px;"
           draggable="true"
           ondragstart="drag(event, {{ posicao.id }})">
                    {{ posicao.participante.personagem.nome|slice:"0:2"|upper }}
                  </div>
                {% endif %}
              {% endif %}
            {% endfor %}
              </div>
            </div>
            <div class="mapa-zoom">
              <button type="button" class="btn btn-sm" data-zoom="out">−</button>
              <button type="button" class="btn btn-sm" data-zoom="reset">Reset</button>
              <button type="button" class="btn btn-sm" data-zoom="in">+</button>
            </div>
            {% if combate.sala.game_master == user %}
              <form method="post" action="{% url 'remover_mapa' combate.id mapa.id %}" class="mapa-remover-form">
                {% csrf_token %}
                <button type="submit" class="btn btn-sm btn-danger">Remover Mapa</button>
              </form>
            {% endif %}
          </div>
        {% endfor %}
      {% endif %}



      {% if combate.sala.game_master == user %}
        {% if combate.mapas.all|length == 0 %}
        <form method="post" enctype="multipart/form-data" action="{% url 'adicionar_mapa' combate.id %}" class="combate-card mapa-upload-form" id="form-mapa">
          {% csrf_token %}
          <input type="hidden" name="mapa_existente" id="mapa_existente_hidden" value="">
          <strong>Envie um Mapa:</strong>
          {{ form.as_p }}
        </form>
        {% else %}
        <!-- Form oculto apenas para permitir a ação "Usar Selecionado" do topo -->
        <form method="post" action="{% url 'adicionar_mapa' combate.id %}" id="form-mapa" style="display:none">
          {% csrf_token %}
          <input type="hidden" name="mapa_existente" id="mapa_existente_hidden" value="">
        </form>
        {% endif %}
      {% endif %}

      <div class="mapa-header-row">
        <h3 class="combate-section-title" style="margin:0">Status dos Participantes</h3>
        {% if personagens_disponiveis %}
        <form method="post" action="{% url 'adicionar_participante' combate.id %}" class="combate-inline-form form-add-participante">
          {% csrf_token %}
          <label for="novo_participante" class="sr-only">Adicionar personagem</label>
          <select name="personagem_id" id="novo_participante" required class="select-sm" title="Adicionar personagem">
            {% for personagem in personagens_disponiveis %}
              <option value="{{ personagem.id }}">{{ personagem.nome }} ({{ personagem.usuario.username }})</option>
            {% endfor %}
          </select>
          <button type="submit" class="btn btn-sm">Adicionar</button>
        </form>
        {% endif %}
        {% if combate.sala.game_master == user and npcs_disponiveis %}
        <form method="post" action="{% url 'adicionar_npc_participante' combate.id %}" class="combate-inline-form form-add-participante">
          {% csrf_token %}
          <label for="novo_npc" class="sr-only">Adicionar NPC</label>
          <select name="npc_id" id="novo_npc" required class="select-sm" title="Adicionar NPC">
            {% for npc in npcs_disponiveis %}
              <option value="{{ npc.id }}">{{ npc.nome }}</option>
            {% endfor %}
          </select>
          <button type="submit" class="btn btn-sm">Adicionar NPC</button>
        </form>
        {% endif %}
      </div>
      <div id="status-card" class="combate-card">
        {% include 'combate/_tabela_participantes.html' %}
      </div>
    </div>
  </div>

  <script>
  // Função reutilizável para sincronizar selects de personagem e poderes (chamada após partial refresh)
  function bindPersonagemAcaoSync() {
    const select = document.getElementById('personagem_acao');
    const poderSelect = document.getElementById('poder');
    if (!select) return;
    const combateId = '{{ combate.id }}';
    const SEL_PARTICIPANTE_KEY = `combate:${combateId}:participante_sel`;
    const powerKey = (personagemId) => `combate:${combateId}:power:${personagemId||''}`;
    const skillKey = (personagemId) => `combate:${combateId}:skill:${personagemId||''}`;
    const traitKey = (personagemId) => `combate:${combateId}:trait:${personagemId||''}`;
    const targetsKey = (personagemId) => `combate:${combateId}:targets:${personagemId||''}`;

    // Sequenciador de requests para evitar race conditions sobrescrevendo selects
    let _poderReqSeq = 0;
    function applyPoderTipoUI(){
      const alvoSelect = document.getElementById('alvo');
      const hint = document.getElementById('alvo_hint');
      const form = document.getElementById('form-ataque');
      const btn = document.getElementById('btn-rolar-poder');
      const poderHint = document.getElementById('poder_hint');
      if (!poderSelect || !alvoSelect) return;
      const opt = poderSelect.options[poderSelect.selectedIndex];
      const tipo = opt ? (opt.dataset.tipo || '') : '';
      if (tipo === 'descritivo') {
        alvoSelect.disabled = true;
        alvoSelect.required = false;
        alvoSelect.setAttribute('aria-required', 'false');
        if (form) form.setAttribute('novalidate', 'novalidate');
        if (btn) btn.setAttribute('formnovalidate', 'formnovalidate');
        if (hint) hint.textContent = 'Poder descritivo: não requer alvos.';
        if (poderHint) poderHint.textContent = 'Rola d20 + nível do poder.';
      } else {
        alvoSelect.disabled = false;
        alvoSelect.required = true;
        alvoSelect.setAttribute('aria-required', 'true');
        if (form) form.removeAttribute('novalidate');
        if (btn) btn.removeAttribute('formnovalidate');
        if (hint) hint.textContent = 'Segure Ctrl (Windows/Linux) ou Cmd (macOS) para selecionar múltiplos; use Shift para selecionar intervalos.';
        if (poderHint) poderHint.textContent = '';
      }
    }
    function bindPoderStorageListener(){
      if (!poderSelect || poderSelect.dataset.boundStorage) return;
      poderSelect.addEventListener('change', function(){
        const opt = select ? select.options[select.selectedIndex] : null;
        const personagemId = opt ? opt.getAttribute('data-personagem-id') : '';
        if (personagemId) {
          try { localStorage.setItem(powerKey(personagemId), String(poderSelect.value||'')); } catch(_) {}
        }
        // Atualiza UI de alvos conforme tipo do poder
        applyPoderTipoUI();
      });
      poderSelect.dataset.boundStorage = '1';
    }
    function restoreSkillAndTrait(personagemId){
      try {
        const perSel = document.getElementById('pericia_rolar');
        const carSel = document.getElementById('caracteristica_rolar');
        const svPer = localStorage.getItem(skillKey(personagemId)) || '';
        const svCar = localStorage.getItem(traitKey(personagemId)) || '';
        if (perSel && svPer) perSel.value = svPer;
        if (carSel && svCar) carSel.value = svCar;
      } catch(_) {}
    }
    function persistSkillAndTraitBind(){
      const perSel = document.getElementById('pericia_rolar');
      const carSel = document.getElementById('caracteristica_rolar');
      if (perSel && !perSel.dataset.persist){
        perSel.addEventListener('change', function(){
          const opt = select ? select.options[select.selectedIndex] : null;
          const personagemId = opt ? opt.getAttribute('data-personagem-id') : '';
          if (personagemId) try { localStorage.setItem(skillKey(personagemId), String(perSel.value||'')); } catch(_) {}
        });
        perSel.dataset.persist = '1';
      }
      if (carSel && !carSel.dataset.persist){
        carSel.addEventListener('change', function(){
          const opt = select ? select.options[select.selectedIndex] : null;
          const personagemId = opt ? opt.getAttribute('data-personagem-id') : '';
          if (personagemId) try { localStorage.setItem(traitKey(personagemId), String(carSel.value||'')); } catch(_) {}
        });
        carSel.dataset.persist = '1';
      }
    }
    function restoreTargets(personagemId){
      try {
        const alvoSel = document.getElementById('alvo');
        if (!alvoSel) return;
        const saved = localStorage.getItem(targetsKey(personagemId));
        if (!saved) return;
        const ids = JSON.parse(saved);
        if (Array.isArray(ids)) {
          Array.from(alvoSel.options).forEach(o => { o.selected = ids.includes(String(o.value)); });
        }
      } catch(_) {}
    }
    function persistTargetsBind(){
      const alvoSel = document.getElementById('alvo');
      if (alvoSel && !alvoSel.dataset.persist){
        alvoSel.addEventListener('change', function(){
          const opt = select ? select.options[select.selectedIndex] : null;
          const personagemId = opt ? opt.getAttribute('data-personagem-id') : '';
          if (personagemId) {
            try {
              const ids = Array.from(alvoSel.selectedOptions || []).map(o => String(o.value));
              localStorage.setItem(targetsKey(personagemId), JSON.stringify(ids));
            } catch(_) {}
          }
        });
        alvoSel.dataset.persist = '1';
      }
    }

    function syncPersonagemAcao() {
      const val = select.value; // participante id
      const selectedOpt = select.options[select.selectedIndex];
      const personagemId = selectedOpt ? selectedOpt.getAttribute('data-personagem-id') : '';
      const h1 = document.getElementById('personagem_acao_hidden');
      const h2 = document.getElementById('personagem_acao_hidden_pericia');
      const h3 = document.getElementById('personagem_acao_hidden_caracteristica');
      const h4 = document.getElementById('personagem_acao_hidden_d20');
      if (h1) h1.value = val; if (h2) h2.value = val; if (h3) h3.value = val; if (h4) h4.value = val;
      // Restaura perícia/traço/alvos persistidos
      restoreSkillAndTrait(personagemId);
      restoreTargets(personagemId);
      if (poderSelect) {
        // Se não houver um personagem válido selecionado, limpa o select de poderes e sai
        if (!personagemId) {
          try {
            poderSelect.innerHTML = '';
            const opt = document.createElement('option');
            opt.disabled = true;
            opt.textContent = 'Selecione um participante';
            poderSelect.appendChild(opt);
          } catch(_) {}
          return;
        }
        // Preferência salva por personagem (se existir)
        let savedValue = '';
        try { savedValue = localStorage.getItem(powerKey(personagemId)) || ''; } catch(_) {}
        const prevValue = poderSelect.value; // fallback: preserva seleção atual
        const mySeq = ++_poderReqSeq;
        fetch('/combate/poderes-personagem-ajax/?personagem_id=' + personagemId)
          .then(resp => resp.json())
          .then(data => {
            // Ignora respostas atrasadas
            if (mySeq !== _poderReqSeq) return;
      poderSelect.innerHTML = '';
            let restored = false;
            if (data.poderes && data.poderes.length > 0) {
              data.poderes.forEach(function(p) {
                const opt = document.createElement('option');
                opt.value = p.id;
                opt.textContent = p.nome;
                if (p.tipo) opt.dataset.tipo = p.tipo;
        if (p.duracao) opt.dataset.duracao = p.duracao;
                // Prefer savedValue; depois tenta prevValue
                if (!restored && savedValue && String(p.id) === String(savedValue)) { opt.selected = true; restored = true; }
                else if (!restored && String(p.id) === String(prevValue)) { opt.selected = true; restored = true; }
                poderSelect.appendChild(opt);
              });
            } else {
              const opt = document.createElement('option');
              opt.disabled = true;
              opt.textContent = 'Nenhum poder disponível';
              poderSelect.appendChild(opt);
            }
            // Se não restaurou, mantém o primeiro como seleção padrão
            if (!restored && poderSelect.options.length) poderSelect.selectedIndex = 0;
            poderSelect.dataset.forPersonagemId = String(personagemId || '');
            // Garante que o listener de storage esteja ativo
            bindPoderStorageListener();
            // Ajusta UI de alvos conforme tipo do poder selecionado
            applyPoderTipoUI();
            // Garante que o clique no botão de poder não dispare validação quando for descritivo
            const btn = document.getElementById('btn-rolar-poder');
            if (btn && !btn.dataset.boundDescritivo) {
              btn.addEventListener('click', function(){
                try {
                  const opt = poderSelect.options[poderSelect.selectedIndex];
                  const tipo = opt ? (opt.dataset.tipo || '') : '';
                  const alvoSel = document.getElementById('alvo');
                  if (tipo === 'descritivo') {
                    this.setAttribute('formnovalidate', 'formnovalidate');
                    if (alvoSel) { alvoSel.disabled = true; alvoSel.required = false; }
                  } else {
                    this.removeAttribute('formnovalidate');
                    if (alvoSel) { alvoSel.disabled = false; alvoSel.required = true; }
                  }
                } catch(_) {}
              });
              btn.dataset.boundDescritivo = '1';
            }
            // Após popular poderes, também reanexar binds de persistência e restaurar escolhas
            persistSkillAndTraitBind();
            persistTargetsBind();
          })
          .catch(() => {/* silencia para evitar reset visual em falhas */});
      }
    }
    // Evita listeners duplicados trocando o nó
    const newSelect = select.cloneNode(true);
    // Restaura escolha persistida do participante (se existir)
    try {
      const savedPart = localStorage.getItem(SEL_PARTICIPANTE_KEY) || '';
      if (savedPart) {
        for (let i = 0; i < newSelect.options.length; i++) {
          if (String(newSelect.options[i].value) === String(savedPart)) { newSelect.selectedIndex = i; break; }
        }
      }
    } catch(_) {}
    select.replaceWith(newSelect);
    newSelect.addEventListener('change', function(){
      try { localStorage.setItem(SEL_PARTICIPANTE_KEY, String(newSelect.value||'')); } catch(_) {}
      syncPersonagemAcao();
    });
    // Garante um valor selecionado válido
    if (newSelect.options.length && newSelect.selectedIndex < 0) newSelect.selectedIndex = 0;
  // Força sincronização inicial com a escolha restaurada
    try { if (newSelect.value) localStorage.setItem(SEL_PARTICIPANTE_KEY, String(newSelect.value)); } catch(_) {}
  // Bind inicial: sempre sincroniza para refletir o selecionado
  syncPersonagemAcao();
    // Assegura listener para salvar seleção
    bindPoderStorageListener();
  // Ajuste inicial do tipo do poder (caso já haja conteudo)
  try { applyPoderTipoUI(); } catch(_) {}
  // Binds de persistência para perícia/traço/alvos
  persistSkillAndTraitBind();
  persistTargetsBind();
    // Bind inicial do botão rolar poder (descritivo no primeiro carregamento)
    const _btnInit = document.getElementById('btn-rolar-poder');
    if (_btnInit && !_btnInit.dataset.boundDescritivo) {
      _btnInit.addEventListener('click', function(){
        try {
          const opt = poderSelect && poderSelect.options ? poderSelect.options[poderSelect.selectedIndex] : null;
          const tipo = opt ? (opt.dataset.tipo || '') : '';
          const alvoSel = document.getElementById('alvo');
          if (tipo === 'descritivo') {
            this.setAttribute('formnovalidate', 'formnovalidate');
            if (alvoSel) { alvoSel.disabled = true; alvoSel.required = false; }
          } else {
            this.removeAttribute('formnovalidate');
            if (alvoSel) { alvoSel.disabled = false; alvoSel.required = true; }
          }
        } catch(_) {}
      });
      _btnInit.dataset.boundDescritivo = '1';
    }
  }
  document.addEventListener('DOMContentLoaded', bindPersonagemAcaoSync);
  </script>

  
</div>

<script>
  document.addEventListener('DOMContentLoaded', function() {
    const combateId = '{{ combate.id }}';
    (function(){
      var rootEl = document.getElementById('combate-content');
      window._IS_GM = !!(rootEl && rootEl.dataset && rootEl.dataset.isGm === 'true');
    })();
    const IS_GM = window._IS_GM;
    const wsScheme = window.location.protocol === 'https:' ? 'wss' : 'ws';
    const wsPath = `${wsScheme}://${window.location.host}/ws/combate/${combateId}/`;
    let combateSocket = new WebSocket(wsPath);
  let lastEventAt = Date.now();

  // Fallback: polling quando WS não estiver disponível ou WS ficar ocioso
    let _combatePollTimer = null;
  function startCombatePolling(){
      if (_combatePollTimer) return;
      let tick = 0;
      _combatePollTimer = setInterval(() => {
        tick = (tick + 1) % 12; // 12 * 5s = 60s
        if (tick === 0) {
          // Atualiza a coluna direita com pouca frequência para evitar reset de selects
          refreshSelectors(['.turno-topbar', '#historico-card', '.combate-col-right']).catch(()=>{});
        } else if (tick === 6) {
          // Evita atualizar a coluna esquerda automaticamente para não trocar seleções de Ações/Poder
          refreshSelectors(['#status-card']).catch(()=>{});
        } else {
          // Atualizações leves frequentes
          refreshSelectors(['.turno-topbar', '#historico-card', '#status-card']).catch(()=>{});
        }
      }, 5000);
    }
    function stopCombatePolling(){ if (_combatePollTimer) { clearInterval(_combatePollTimer); _combatePollTimer = null; } }
    // Heartbeat: se não chegar nenhuma mensagem por um tempo, ativa polling auxiliar
    let _hbTimer = null;
    function startHeartbeat(){
      if (_hbTimer) return;
      _hbTimer = setInterval(() => {
        const idleMs = Date.now() - lastEventAt;
        if (idleMs > 12000) { // >12s sem eventos: garante refresh e polling ligado
          startCombatePolling();
          // Atualiza direita sem tocar no formulário de ações
          refreshSelectors(['.turno-topbar', '#historico-card', '.combate-col-right', '#status-card']).catch(()=>{});
        }
      }, 8000);
    }
    function stopHeartbeat(){ if (_hbTimer) { clearInterval(_hbTimer); _hbTimer = null; } }

    // Persistência de preferências da grade por combate
    const GRID_ENABLED_KEY = `combate:${combateId}:gridEnabled`;
    const GRID_SIZE_KEY = `combate:${combateId}:gridSize`;
    function persistGridState() {
      const cb = document.getElementById('grid-enable');
      const sel = document.getElementById('grid-size');
      if (cb) localStorage.setItem(GRID_ENABLED_KEY, cb.checked ? '1' : '0');
      if (sel) localStorage.setItem(GRID_SIZE_KEY, sel.value || '40');
    }
    function restoreGridStateIfNeeded() {
      const cb = document.getElementById('grid-enable');
      const sel = document.getElementById('grid-size');
      const savedEnabled = localStorage.getItem(GRID_ENABLED_KEY);
      const savedSize = localStorage.getItem(GRID_SIZE_KEY);
      if (cb && !cb.dataset.restored && savedEnabled !== null) {
        cb.checked = savedEnabled === '1';
        cb.dataset.restored = '1';
      }
      if (sel && !sel.dataset.restored && savedSize) {
        sel.value = savedSize;
        sel.dataset.restored = '1';
      }
    }


    // ====== Grade (grid) opcional para melhorar precisão com zoom ======
  function gridEnabled(){
      const cb = document.getElementById('grid-enable');
      return !!(cb && cb.checked);
    }
    function getGridSize(){
      const sel = document.getElementById('grid-size');
      const v = sel && parseInt(sel.value, 10);
      return Number.isFinite(v) && v > 4 ? v : 40;
    }
    function applyGridSnap(x, y){
      const cell = getGridSize();
      x = Math.round(x / cell) * cell;
      y = Math.round(y / cell) * cell;
      return {x, y};
    }
    function updateGridForArea(mapaArea){
      const canvas = mapaArea && mapaArea.querySelector('.mapa-canvas');
      if (!canvas) return;
      if (!gridEnabled()){
        canvas.style.backgroundImage = '';
        canvas.style.backgroundSize = '';
        canvas.style.backgroundPosition = '';
        return;
      }
      const scale = parseFloat(mapaArea.dataset.scale || '1');
      const cell = getGridSize();
      const cellPx = Math.max(4, Math.round(cell * scale));
      // Linhas de 1px cinza claro; duas grades (x e y)
      const line = 'rgba(0,0,0,0.12)';
      canvas.style.backgroundImage = `
        repeating-linear-gradient(to right, ${line} 0, ${line} 1px, transparent 1px, transparent ${cellPx}px),
        repeating-linear-gradient(to bottom, ${line} 0, ${line} 1px, transparent 1px, transparent ${cellPx}px)
      `;
      canvas.style.backgroundSize = `${cellPx}px ${cellPx}px`;
      canvas.style.backgroundPosition = '0 0';
    }
    function updateAllGrids(){
      document.querySelectorAll("[id^='mapa-area-']").forEach(updateGridForArea);
    }
    // Garante que imagens pequenas sejam ampliadas para cobrir a área visível
    function ensureMinScaleForArea(mapaArea){
      if (!mapaArea) return;
      const canvas = mapaArea.querySelector('.mapa-canvas');
      const img = canvas ? canvas.querySelector('.mapa-img') : null;
      if (!canvas || !img) return;
      const areaW = mapaArea.clientWidth || 1;
      const areaH = mapaArea.clientHeight || 1;
      const baseW = img.naturalWidth || img.clientWidth || 1;
      const baseH = img.naturalHeight || img.clientHeight || 1;
      const fitW = areaW / (baseW || areaW);
      const fitH = areaH / (baseH || areaH);
      const minScale = Math.max(fitW, fitH); // permite upscaling
      let cur = parseFloat(mapaArea.dataset.scale || '1') || 1;
      if (cur < minScale || !isFinite(cur)) {
        cur = minScale;
        mapaArea.dataset.scale = String(cur);
        canvas.style.transform = `scale(${cur})`;
        canvas.style.minWidth = (baseW * cur) + 'px';
        canvas.style.minHeight = (baseH * cur) + 'px';
        updateGridForArea(mapaArea);
      }
    }
    function ensureAllAreasMinScale(){
      document.querySelectorAll("[id^='mapa-area-']").forEach(ensureMinScaleForArea);
    }
    // ====== Persistência do tamanho dos tokens (Ctrl + Scroll) ======
    function tokenSizeKey(posicaoId){ return `combate:${combateId}:token:${posicaoId}:size`; }
    function persistTokenSize(tokenEl){
      if (!tokenEl || !tokenEl.id) return;
      const id = (tokenEl.id || '').replace('token-','');
      try {
        const w = parseFloat(getComputedStyle(tokenEl).width) || 40;
        localStorage.setItem(tokenSizeKey(id), String(Math.round(w)));
      } catch(_) {}
    }
    function restoreTokenSize(tokenEl){
      if (!tokenEl || !tokenEl.id) return;
      const id = (tokenEl.id || '').replace('token-','');
      try {
        const saved = parseFloat(localStorage.getItem(tokenSizeKey(id)) || '');
        if (Number.isFinite(saved) && saved > 0) {
          tokenEl.style.width = saved + 'px';
          tokenEl.style.height = saved + 'px';
        }
      } catch(_) {}
    }
    function restoreTokenSizes(scope){
      (scope || document).querySelectorAll('.mapa-token').forEach(restoreTokenSize);
    }
    // ====== Persistência de selects sujeitos a refresh (mapa/add participante/NPC) ======
    function persistSelectById(id, key){
      const el = document.getElementById(id);
      if (!el) return;
      // Restore saved value
      try {
        const saved = localStorage.getItem(key);
        if (saved) {
          for (let i=0;i<el.options.length;i++) {
            if (String(el.options[i].value) === String(saved)) { el.selectedIndex = i; break; }
          }
        }
      } catch(_) {}
      if (!el.dataset.persistBound) {
        el.addEventListener('change', () => { try { localStorage.setItem(key, String(el.value||'')); } catch(_) {} });
        el.dataset.persistBound = '1';
      }
    }
    function setupGridControls(){
      const cb = document.getElementById('grid-enable');
      const sel = document.getElementById('grid-size');
      // Restaura estado salvo (se houver)
      restoreGridStateIfNeeded();
      if (cb && !cb.dataset.bound){
        cb.addEventListener('change', () => { persistGridState(); updateAllGrids(); });
        cb.dataset.bound = '1';
      }
      if (sel && !sel.dataset.bound){
        sel.addEventListener('change', () => { persistGridState(); updateAllGrids(); });
        sel.dataset.bound = '1';
      }
    }

  // Torna helpers acessíveis globalmente para outros blocos/scripts
  window.gridEnabled = gridEnabled;
  window.getGridSize = getGridSize;
  window.applyGridSnap = applyGridSnap;
  window.updateGridForArea = updateGridForArea;
  window.updateAllGrids = updateAllGrids;
  window.setupGridControls = setupGridControls;

    // ====== Persistência de estado do mapa (zoom/scroll) ======
    function saveMapStates(){
      const states = {};
      document.querySelectorAll("[id^='mapa-area-']").forEach(area => {
        const id = (area.id || '').replace('mapa-area-','');
        states[id] = {
          scale: parseFloat(area.dataset.scale || '1') || 1,
          scrollLeft: area.scrollLeft || 0,
          scrollTop: area.scrollTop || 0,
        };
      });
      window._mapStates = states;
    }
    function restoreMapStates(){
      const states = window._mapStates || {};
      document.querySelectorAll("[id^='mapa-area-']").forEach(area => {
        const id = (area.id || '').replace('mapa-area-','');
        const st = states[id];
        const canvas = area.querySelector('.mapa-canvas');
        const img = canvas ? canvas.querySelector('.mapa-img') : null;
        if (!st || !canvas || !img) return;
        let scale = parseFloat(st.scale || 1) || 1;
        // Recalcula limites dinâmicos e aplica transform
        const rect = canvas.getBoundingClientRect();
        const baseW = img.naturalWidth || img.clientWidth || rect.width || 1;
        const baseH = img.naturalHeight || img.clientHeight || rect.height || 1;
        const areaW = area.clientWidth || 1;
        const areaH = area.clientHeight || 1;
        const fitW = areaW / (baseW || areaW);
        const fitH = areaH / (baseH || areaH);
  // Permite upscaling quando a imagem é menor que a área visível
  const minScale = Math.max(fitW, fitH);
        const maxScale = 3;
        scale = Math.max(minScale, Math.min(maxScale, scale));
        area.dataset.scale = String(scale);
        canvas.style.transform = `scale(${scale})`;
        canvas.style.minWidth = (baseW * scale) + 'px';
        canvas.style.minHeight = (baseH * scale) + 'px';
        // Restaura scroll (com clamp natural pelos bounds atuais)
        area.scrollLeft = st.scrollLeft || 0;
        area.scrollTop = st.scrollTop || 0;
        if (typeof updateGridForArea === 'function') updateGridForArea(area);
      });
    }

    // Utilitários para refresh parcial
    async function fetchPageDOM() {
      const resp = await fetch(window.location.href, { cache: 'no-store' });
      const html = await resp.text();
      const parser = new DOMParser();
      return parser.parseFromString(html, 'text/html');
    }
  async function refreshSelectors(selectors) {
      try {
        // Garante que a preferência atual da grade não se perca durante o refresh
        persistGridState();
        // Salva estados atuais do mapa (zoom/scroll) para restaurar após troca
        saveMapStates();
        // Hist: detecta se o usuário está perto do fim para preservar leitura
        let historicoWasNearBottom = false;
        try {
          const hc = document.getElementById('historico-card');
          if (hc) historicoWasNearBottom = (hc.scrollHeight - hc.scrollTop - hc.clientHeight) < 24;
        } catch(_) {}
        // Preserva seleção de alvos quando o formulário de ataque for atualizado
        let savedAlvos = null;
        try {
          if ((selectors || []).some(s => s === '#form-ataque')) {
            const alvoSel = document.getElementById('alvo');
            if (alvoSel) {
              savedAlvos = Array.from(alvoSel.selectedOptions || []).map(o => String(o.value));
            }
          }
        } catch(_) {}
        const doc = await fetchPageDOM();
        // Prepare nodes once to avoid parent/child conflicts
        const items = [];
        const uniq = Array.from(new Set(selectors || []));
        for (const sel of uniq) {
          const fresh = doc.querySelector(sel);
          if (fresh) {
            // Compute depth for ordering (parents first)
            let d = 0, n = fresh;
            while (n && n.parentElement) { d++; n = n.parentElement; }
            items.push({ sel, fresh, depth: d });
          }
        }
        // Remove descendants when their ancestor is already scheduled
        items.sort((a,b)=>a.depth-b.depth);
        const filtered = [];
        for (let i=0;i<items.length;i++){
          let isDescendant = false;
          for (let j=0;j<filtered.length && !isDescendant;j++){
            if (filtered[j].fresh.contains(items[i].fresh)) isDescendant = true;
          }
          if (!isDescendant) filtered.push(items[i]);
        }
        // Replace in DOM using the pre-collected fresh nodes
        for (const it of filtered) {
          const target = document.querySelector(it.sel);
          if (target && it.fresh) target.replaceWith(it.fresh);
        }
        // Reaplica comportamentos após substituições
    rafEqualize();
  // Restaura estados do mapa após substituição
        restoreMapStates();
  // Se não houver estado salvo (primeira vez), garanta cobertura
  ensureAllAreasMinScale();
        // Autoscroll apenas se antes já estava perto do fim
        const historico = document.getElementById('historico-card');
        if (historicoWasNearBottom && historico && historico.scrollHeight > historico.clientHeight) {
          historico.scrollTop = historico.scrollHeight;
        }
  // Rebind drag & drop após trocas da coluna direita
        rebindDragDrop();
  // Rebind ações do topo se a barra de turno foi trocada
    setupTopbarMapActions();
  // Rebind e atualizar grade
  setupGridControls();
  updateAllGrids();
  // Após re-render, restaura tamanhos salvos dos tokens
  try { restoreTokenSizes(document); } catch(_) {}
  // Rebind dos formulários para evitar navegação
  ajaxifyInteractionForms();
  // Rebind dos selects de personagem/ataque, para atualizar poderes
  bindPersonagemAcaoSync();
  // Restaura selects persistidos
  try {
    persistSelectById('mapa_existente_top', `combate:${combateId}:mapa_existente_top`);
    persistSelectById('novo_participante', `combate:${combateId}:novo_participante`);
    persistSelectById('novo_npc', `combate:${combateId}:novo_npc`);
    // Restaura seleção de alvos após recarregar o form de ataque
    if (savedAlvos && savedAlvos.length) {
      const alvoSel2 = document.getElementById('alvo');
      if (alvoSel2) {
        Array.from(alvoSel2.options).forEach(o => { o.selected = savedAlvos.indexOf(String(o.value)) !== -1; });
      }
    }
  } catch(_) {}
      } catch (err) {
        console.warn('Refresh parcial falhou, mantendo página:', err);
      }
    }
    function rebindDragDrop(){
      document.querySelectorAll("[id^='mapa-area-']").forEach(function(mapaArea) {
        mapaArea.addEventListener('dragover', function(e){ e.preventDefault(); });
        mapaArea.addEventListener('drop', function(e){
          e.preventDefault();
          const tokenId = e.dataTransfer.getData('tokenId');
          const canvas = mapaArea.querySelector('.mapa-canvas') || mapaArea;
          const rect = canvas.getBoundingClientRect();
          const scale = parseFloat(mapaArea.dataset.scale || '1');
          const tokenEl = document.getElementById('token-' + tokenId);
          const tokenSize = tokenEl ? parseFloat(getComputedStyle(tokenEl).width) || 40 : 40;
          const half = tokenSize / 2;
          let x = (e.clientX - rect.left - half) / scale;
          let y = (e.clientY - rect.top - half) / scale;
          // Clamp to image bounds (pre-transform coordinates)
          const img = canvas.querySelector('.mapa-img');
          const baseW = img ? (img.naturalWidth || img.clientWidth) : 0;
          const baseH = img ? (img.naturalHeight || img.clientHeight) : 0;
          if (baseW && baseH) {
            x = Math.max(0, Math.min(baseW - tokenSize, x));
            y = Math.max(0, Math.min(baseH - tokenSize, y));
          }
          // Snap opcional à grade
          if (gridEnabled()) { const snapped = applyGridSnap(x, y); x = snapped.x; y = snapped.y; }
          fetch(`/combate/atualizar-posicao-token/${tokenId}/`, {
            method: 'POST',
            headers: { 'X-CSRFToken': '{{ csrf_token }}', 'Content-Type': 'application/json' },
            credentials: 'same-origin',
            body: JSON.stringify({x,y})
          }).then(() => {
            const token = document.getElementById('token-' + tokenId);
            if (token) { token.style.left = x + 'px'; token.style.top = y + 'px'; }
          });
        });

        // Per-token resize with Ctrl + wheel over the token
        function bindTokenWheelResize() {
          mapaArea.querySelectorAll('.mapa-token').forEach(token => {
            if (token.dataset.wheelResized) return;
            token.addEventListener('wheel', function(e){
              if (!e.ctrlKey) return; // only when holding Ctrl
              e.preventDefault();
              e.stopPropagation();
              e.stopImmediatePropagation();
              const cs = getComputedStyle(token);
              const cur = parseFloat(cs.width) || 40;
              const dir = e.deltaY > 0 ? -1 : 1;
              const factor = dir > 0 ? 1.1 : 1/1.1;
              let next = +(cur * factor).toFixed(2);
              const min = 20, max = 120;
              next = Math.max(min, Math.min(max, next));
              token.style.width = next + 'px';
              token.style.height = next + 'px';
              try { persistTokenSize(token); } catch(_) {}
              // Persiste no servidor também
              try {
                const id = (token.id || '').replace('token-','');
                fetch(`/combate/atualizar-posicao-token/${id}/`, {
                  method: 'POST',
                  headers: { 'X-CSRFToken': '{{ csrf_token }}', 'Content-Type': 'application/json' },
                  credentials: 'same-origin',
                  body: JSON.stringify({ size: next })
                }).catch(()=>{});
              } catch(_) {}
            }, { passive: false });
            token.dataset.wheelResized = '1';
            try { restoreTokenSize(token); } catch(_) {}
          });
        }
        bindTokenWheelResize();

        // Helper to set scale, expand scrollable area, and keep pointer focus (if pivot provided)
        function setScale(newScale, pivotEvent){
          const canvas = mapaArea.querySelector('.mapa-canvas');
          const img = canvas ? canvas.querySelector('.mapa-img') : null;
          if (!canvas || !img) return;
          const oldScale = parseFloat(mapaArea.dataset.scale || '1');
          const rect = canvas.getBoundingClientRect();
          // Base (natural) size
          const baseW = img.naturalWidth || img.clientWidth || rect.width;
          const baseH = img.naturalHeight || img.clientHeight || rect.height;
          // Container size and dynamic min scale to keep map covering the viewport
          const areaW = mapaArea.clientWidth || 1;
          const areaH = mapaArea.clientHeight || 1;
          const fitW = areaW / (baseW || areaW);
          const fitH = areaH / (baseH || areaH);
          // Permite upscaling para cobrir a viewport quando a imagem for pequena
          const minScale = Math.max(fitW, fitH);
          const maxScale = 3;
          newScale = Math.max(minScale, Math.min(maxScale, newScale));
          // Apply transform and enlarge scrollable box so scrollbars match zoom
          mapaArea.dataset.scale = String(newScale);
          canvas.style.transform = `scale(${newScale})`;
          canvas.style.minWidth = (baseW * newScale) + 'px';
          canvas.style.minHeight = (baseH * newScale) + 'px';
          // Atualiza grade com novo zoom
          updateGridForArea(mapaArea);

          // Preserve focal point under cursor if event provided
          if (pivotEvent) {
            const areaRect = mapaArea.getBoundingClientRect();
            const pointerX = pivotEvent.clientX - areaRect.left;
            const pointerY = pivotEvent.clientY - areaRect.top;
            const sx = mapaArea.scrollLeft;
            const sy = mapaArea.scrollTop;
            const nx = (sx + pointerX) * (newScale / oldScale) - pointerX;
            const ny = (sy + pointerY) * (newScale / oldScale) - pointerY;
            const maxScrollX = Math.max(0, mapaArea.scrollWidth - mapaArea.clientWidth);
            const maxScrollY = Math.max(0, mapaArea.scrollHeight - mapaArea.clientHeight);
            mapaArea.scrollLeft = Math.min(maxScrollX, Math.max(0, nx));
            mapaArea.scrollTop = Math.min(maxScrollY, Math.max(0, ny));
          }
        }

        // Zoom controls (bar is outside the scrollable area, in the wrapper)
        const wrapper = mapaArea.closest('.mapa-wrapper') || mapaArea.parentElement;
        const zoomBar = wrapper ? wrapper.querySelector('.mapa-zoom') : null;
        const canvas = mapaArea.querySelector('.mapa-canvas');
        if (zoomBar && canvas) {
          zoomBar.querySelectorAll('button[data-zoom]').forEach(btn => {
            // Remove previous listeners by cloning (in case of rebinds)
            const cloned = btn.cloneNode(true);
            btn.replaceWith(cloned);
            cloned.addEventListener('click', function(){
              const action = this.getAttribute('data-zoom');
              let scale = parseFloat(mapaArea.dataset.scale || '1');
              if (action === 'in') scale = +(scale * 1.1).toFixed(3);
              else if (action === 'out') scale = +(scale / 1.1).toFixed(3);
              else scale = 1;
              setScale(scale);
            });
          });
        }

        // Clamp scroll so it never goes beyond the scaled image area
        if (!mapaArea.dataset.scrollBound) {
          mapaArea.addEventListener('scroll', function(){
            const canvas = mapaArea.querySelector('.mapa-canvas');
            const img = canvas ? canvas.querySelector('.mapa-img') : null;
            if (!img) return;
            const scale = parseFloat(mapaArea.dataset.scale || '1');
            const baseW = img.naturalWidth || img.clientWidth || 0;
            const baseH = img.naturalHeight || img.clientHeight || 0;
            const maxX = Math.max(0, baseW * scale - mapaArea.clientWidth);
            const maxY = Math.max(0, baseH * scale - mapaArea.clientHeight);
            if (mapaArea.scrollLeft > maxX) mapaArea.scrollLeft = maxX;
            if (mapaArea.scrollTop > maxY) mapaArea.scrollTop = maxY;
            if (mapaArea.scrollLeft < 0) mapaArea.scrollLeft = 0;
            if (mapaArea.scrollTop < 0) mapaArea.scrollTop = 0;
          }, { passive: true });
          mapaArea.dataset.scrollBound = '1';
        }

        // Panning: Middle mouse or Space + Left drag
        function clampScrollToBounds() {
          const canvas = mapaArea.querySelector('.mapa-canvas');
          const img = canvas ? canvas.querySelector('.mapa-img') : null;
          if (!img) return;
          const scale = parseFloat(mapaArea.dataset.scale || '1');
          const baseW = img.naturalWidth || img.clientWidth || 0;
          const baseH = img.naturalHeight || img.clientHeight || 0;
          const maxX = Math.max(0, baseW * scale - mapaArea.clientWidth);
          const maxY = Math.max(0, baseH * scale - mapaArea.clientHeight);
          if (mapaArea.scrollLeft > maxX) mapaArea.scrollLeft = maxX;
          if (mapaArea.scrollTop > maxY) mapaArea.scrollTop = maxY;
          if (mapaArea.scrollLeft < 0) mapaArea.scrollLeft = 0;
          if (mapaArea.scrollTop < 0) mapaArea.scrollTop = 0;
        }

        function bindPan(){
          if (!window._mapPanKeyBound) {
            window._mapSpacePressed = false;
            window.addEventListener('keydown', (ev)=>{ if (ev.code === 'Space') { window._mapSpacePressed = true; ev.preventDefault(); } }, { capture:true });
            window.addEventListener('keyup', (ev)=>{ if (ev.code === 'Space') { window._mapSpacePressed = false; ev.preventDefault(); } }, { capture:true });
            window._mapPanKeyBound = true;
          }
          if (mapaArea.dataset.panBound) return;
          let panning = false, startX = 0, startY = 0, startL = 0, startT = 0;
          function onMove(ev){
            if (!panning) return;
            const dx = ev.clientX - startX;
            const dy = ev.clientY - startY;
            mapaArea.scrollLeft = startL - dx;
            mapaArea.scrollTop = startT - dy;
            clampScrollToBounds();
          }
          function endPan(){
            if (!panning) return;
            panning = false;
            mapaArea.classList.remove('panning');
            window.removeEventListener('mousemove', onMove, true);
            window.removeEventListener('mouseup', endPan, true);
          }
          mapaArea.addEventListener('mousedown', function(ev){
            const isMiddle = ev.button === 1;
            const isSpaceDrag = ev.button === 0 && window._mapSpacePressed;
            if (!isMiddle && !isSpaceDrag) return;
            ev.preventDefault();
            ev.stopPropagation();
            panning = true;
            startX = ev.clientX; startY = ev.clientY;
            startL = mapaArea.scrollLeft; startT = mapaArea.scrollTop;
            mapaArea.classList.add('panning');
            window.addEventListener('mousemove', onMove, true);
            window.addEventListener('mouseup', endPan, true);
          }, { capture:true });
          // Prevent token drag when holding space
          mapaArea.addEventListener('dragstart', function(ev){ if (window._mapSpacePressed) { ev.preventDefault(); ev.stopImmediatePropagation(); } }, true);
          mapaArea.dataset.panBound = '1';
        }
        bindPan();

        // Ctrl + wheel zoom (once)
        if (!mapaArea.dataset.wheelBound) {
          mapaArea.addEventListener('wheel', function(e){
            if (!e.ctrlKey) return;
            e.preventDefault();
            let scale = parseFloat(mapaArea.dataset.scale || '1');
            const dir = e.deltaY > 0 ? -1 : 1; // up = zoom in
            const factor = dir > 0 ? 1.1 : 1/1.1;
            scale = +(scale * factor).toFixed(3);
            setScale(scale, e);
          }, { passive: false });
          mapaArea.dataset.wheelBound = '1';
        }
      });
    }

    // ====== Helpers globais para atualizar selects (Alvos e Ações de) ======
    function ensureAlvoHasParticipant(part){
      try {
        const sel = document.getElementById('alvo');
        if (!sel || !part) return;
        const idStr = String(part.id);
        const exists = Array.from(sel.options).some(o => String(o.value) === idStr);
        if (!exists) {
          const opt = document.createElement('option');
          opt.value = idStr;
          opt.textContent = part.nome || `#${idStr}`;
          sel.appendChild(opt);
        }
      } catch(_) {}
    }
    function maybeAddToAcoesDe(part){
      if (!IS_GM || !part) return;
      try {
        const sel = document.getElementById('personagem_acao');
        if (!sel) return;
        const idStr = String(part.id);
        const exists = Array.from(sel.options).some(o => String(o.value) === idStr);
        if (!exists) {
          const opt = document.createElement('option');
          opt.value = idStr;
          opt.dataset.personagemId = String(part.personagem_id || '');
          opt.setAttribute('data-personagem-id', String(part.personagem_id || ''));
          opt.textContent = part.nome || `#${idStr}`;
          sel.appendChild(opt);
        }
      } catch(_) {}
    }
    function removeFromAlvo(id){
      try {
        const sel = document.getElementById('alvo');
        if (sel && id) {
          Array.from(sel.options).forEach(o => { if (String(o.value) === String(id)) o.remove(); });
        }
      } catch(_) {}
    }
    function removeFromAcoesDe(id){
      if (!IS_GM || !id) return;
      try {
        const sel = document.getElementById('personagem_acao');
        if (!sel) return;
        Array.from(sel.options).forEach(o => { if (String(o.value) === String(id)) o.remove(); });
      } catch(_) {}
    }

    // ====== AJAXify de formulários para evitar reload ======
    function bindAjax(form){
      if (!form || form.dataset.ajaxified === '1') return;
      form.addEventListener('submit', function(e){
        e.preventDefault();
        const submitter = e.submitter || null;
        // Garante que os campos hidden do atacante reflitam o valor atual de "Ações de"
        try {
          const selAtacante = document.getElementById('personagem_acao');
          const val = selAtacante ? selAtacante.value : '';
          ['personagem_acao_hidden','personagem_acao_hidden_pericia','personagem_acao_hidden_caracteristica','personagem_acao_hidden_d20']
            .forEach(id => { const h = document.getElementById(id); if (h) h.value = val; });
        } catch(_) {}
        let fd;
        try { fd = new FormData(form, submitter); }
        catch(_){ fd = new FormData(form); if (submitter && submitter.name) fd.append(submitter.name, submitter.value || '1'); }
        const btn = submitter || form.querySelector('button[type="submit"]');
        if (btn) btn.disabled = true;
        // Se poder descritivo estiver selecionado, assegura que nenhum campo alvo bloqueie o envio
        try {
          const poderSel = form.querySelector('#poder');
          const alvoSel = form.querySelector('#alvo');
          const opt = poderSel ? poderSel.options[poderSel.selectedIndex] : null;
          const tipo = opt ? (opt.dataset.tipo || '') : '';
          if (tipo === 'descritivo' && alvoSel) {
            alvoSel.disabled = true; // evita validação nativa
          }
        } catch(_) {}
        fetch(form.action, {
          method: 'POST',
          body: fd,
          headers: { 'X-Requested-With': 'XMLHttpRequest', 'Accept': 'application/json' },
          credentials: 'same-origin'
        }).then(async (resp) => {
          const ct = (resp.headers.get('content-type') || '').toLowerCase();
          let data = null;
          if (ct.includes('application/json')) { try { data = await resp.json(); } catch(_) {} }
          if (!resp.ok) throw new Error('request_failed');
          // Prefer targeted updates when possible; otherwise, generic refresh
          if (data && data.evento) {
            switch (data.evento) {
              case 'rolagem':
                await refreshSelectors(['#historico-card', '#status-card']);
                break;
              case 'adicionar_participante':
                // Atualiza selects localmente de imediato
                if (data.participante) {
                  ensureAlvoHasParticipant(data.participante);
                  maybeAddToAcoesDe(data.participante);
                }
                // Atualize apenas direita e status
                await refreshSelectors(['.combate-col-right', '#status-card']);
                try {
                  const idStr = String(data.participante && data.participante.id);
                  const alvoSel = document.getElementById('alvo');
                  const has = alvoSel && Array.from(alvoSel.options).some(o => String(o.value) === idStr);
                  if (!has && idStr) { await refreshSelectors(['#form-ataque']); }
                } catch(_) {}
                break;
              case 'remover_participante':
                if (data.participante_id) {
                  removeFromAlvo(data.participante_id);
                  removeFromAcoesDe(data.participante_id);
                }
                // Evita trocar elementos da coluna esquerda para não resetar selects
                await refreshSelectors(['.combate-col-right', '#status-card']);
                break;
              case 'iniciar_turno':
              case 'avancar_turno':
              case 'finalizar_combate':
                await refreshSelectors(['.turno-topbar', '#historico-card', '#status-card']);
                break;
              case 'adicionar_mapa':
              case 'remover_mapa':
                await refreshSelectors(['.combate-col-right']);
                break;
              case 'limpar_historico':
                // Não toque no form de ataque; só limpa topbar e histórico
                await refreshSelectors(['.turno-topbar', '#historico-card']);
                break;
              default:
                await refreshSelectors(['.turno-topbar', '#historico-card', '.combate-col-right']);
            }
          } else {
            await refreshSelectors(['.turno-topbar', '#historico-card', '.combate-col-right']);
          }
        }).catch(async () => {
          // Generic fallback on error
          try { await refreshSelectors(['.turno-topbar', '#historico-card', '.combate-col-right']); } catch(_) {}
        }).finally(() => {
          if (btn) btn.disabled = false;
          // Reativa alvo após envio
          try { const alvoSel = form.querySelector('#alvo'); if (alvoSel) alvoSel.disabled = false; } catch(_) {}
        });
      });
      form.dataset.ajaxified = '1';
    }
    function ajaxifyInteractionForms(){
      bindAjax(document.getElementById('form-d20'));
      bindAjax(document.getElementById('form-ataque'));
  bindAjax(document.getElementById('form-mapa'));
      document.querySelectorAll('.turno-topbar-actions form').forEach(bindAjax);
  document.querySelectorAll('.form-remover-participante').forEach(bindAjax);
  document.querySelectorAll('.form-add-participante').forEach(bindAjax);
    document.querySelectorAll('.form-limpar-historico').forEach(bindAjax);
  document.querySelectorAll('.mapa-remover-form').forEach(bindAjax);
    }

    combateSocket.onmessage = async function(e) {
  lastEventAt = Date.now();
      let payload = null;
      try { payload = JSON.parse(e.data); } catch(_) {}
      if (!payload || !payload.evento) {
        // Desconhecido: faça refresh leve dos principais blocos
  await refreshSelectors(['.turno-topbar', '#historico-card', '#status-card']);
        return;
      }
      switch (payload.evento) {
        case 'token_move': {
          // Atualiza apenas o token informado, sem refresh de colunas
          const id = payload.posicao_id;
          const x = payload.x; const y = payload.y;
          const token = document.getElementById('token-' + id);
          if (token && Number.isFinite(x) && Number.isFinite(y)) {
            token.style.left = x + 'px';
            token.style.top = y + 'px';
          }
          break;
        }
        case 'token_resize': {
          const id = payload.posicao_id;
          const size = payload.size;
          const token = document.getElementById('token-' + id);
          if (token && Number.isFinite(size)) {
            token.style.width = size + 'px';
            token.style.height = size + 'px';
            try { persistTokenSize(token); } catch(_) {}
          }
          break;
        }
        case 'rolagem': {
          // Acrescenta somente ao histórico
          const ativo = document.querySelector('.turnos-list .turno-item.ativo .turno-desc')
                        || document.querySelector('.turnos-list .turno-item:last-child .turno-desc');
          if (ativo) {
            const extra = document.createElement('div');
            extra.innerHTML = payload.descricao || '';
            // Preserva quebras de linha como HTML
            ativo.innerHTML = (ativo.innerHTML ? ativo.innerHTML + '<br>' : '') + extra.innerHTML;
            const historico = document.getElementById('historico-card');
            if (historico && historico.scrollHeight > historico.clientHeight) historico.scrollTop = historico.scrollHeight;
            // Garante atualização do status dos participantes sem recarregar a página inteira
            await refreshSelectors(['#status-card']);
          } else {
            await refreshSelectors(['#historico-card', '#status-card']);
          }
          break;
        }
        case 'limpar_historico': {
          await refreshSelectors(['.turno-topbar', '#historico-card', '#form-ataque']);
          break;
        }
  case 'adicionar_mapa':
  case 'remover_mapa': {
          await refreshSelectors(['.combate-col-right']);
          break;
        }
        case 'adicionar_participante': {
          ensureAlvoHasParticipant(payload && payload.participante);
          maybeAddToAcoesDe(payload && payload.participante);
          // Atualiza apenas a coluna direita (mapa + status) — não toque no form da esquerda
          await refreshSelectors(['.combate-col-right', '#status-card']);
          // Fallback mínimo: apenas se o alvo não existir no select, atualize o form de ataque
          try {
            const idStr = String(payload && payload.participante && payload.participante.id);
            const alvoSel = document.getElementById('alvo');
            const has = alvoSel && Array.from(alvoSel.options).some(o => String(o.value) === idStr);
            if (!has && idStr) {
              await refreshSelectors(['#form-ataque']);
            }
          } catch(_) {}
          break;
        }
        case 'remover_participante': {
          removeFromAlvo(payload && payload.participante_id);
          removeFromAcoesDe(payload && payload.participante_id);
          // Atualiza apenas a coluna direita (mapa + status) — não toque no form da esquerda
          await refreshSelectors(['.combate-col-right', '#status-card']);
          removeFromAlvo(payload && payload.participante_id);
          break;
        }
        case 'iniciar_turno':
        case 'avancar_turno':
        case 'finalizar_combate': {
          await refreshSelectors(['.turno-topbar', '#historico-card', '#status-card']);
          break;
        }
        default: {
          // Evento desconhecido: evita recarregar o mapa; atualiza cabeçalho, histórico e status
          await refreshSelectors(['.turno-topbar', '#historico-card', '#status-card']);
        }
      }
    };

    combateSocket.onopen = function(){ stopCombatePolling(); };
    combateSocket.onclose = function(e) {
      console.warn('WebSocket fechado. Atualização por polling ativada.');
      startCombatePolling();
    };
  startHeartbeat();

    window.enviarMensagemCombate = function(msg) {
      combateSocket.send(msg);
    };

    // ====== Equalização de alturas (Mapa x Ações) e (Histórico x Status) ======
    function equalizarAlturas() {
      const isStacked = window.matchMedia('(max-width: 1000px)').matches;
      const acoesCard = document.getElementById('form-ataque');
      const acaoTopRow = document.querySelector('.acao-top-row');
      const mapaAreas = document.querySelectorAll('.mapa-area');
      const historicoCard = document.getElementById('historico-card');
      const statusCard = document.getElementById('status-card');

      const outerH = (el) => {
        if (!el) return 0;
        const cs = getComputedStyle(el);
        return el.offsetHeight + parseFloat(cs.marginTop || 0) + parseFloat(cs.marginBottom || 0);
      };

      // Reset when stacked
      if (isStacked) {
        mapaAreas.forEach(m => m.style.height = '');
        if (historicoCard) {
          historicoCard.style.height = '';
          historicoCard.style.maxHeight = '';
          historicoCard.style.overflowY = '';
        }
        return;
      }

      // Mapa do Combate = altura do bloco de Ações (linha do topo + card), incluindo margens
      if (mapaAreas.length) {
        const alvoAlt = outerH(acaoTopRow) + outerH(acoesCard);
        mapaAreas.forEach(m => m.style.height = Math.max(360, alvoAlt) + 'px');
      }

      // Histórico = mesma altura do Status; se maior, aplica scroll
      if (historicoCard && statusCard) {
        const statusAlt = statusCard.offsetHeight;
        historicoCard.style.height = statusAlt + 'px';
        historicoCard.style.maxHeight = statusAlt + 'px';
        historicoCard.style.overflowY = 'auto';
        // Mantém o scroll sempre no final para mostrar os eventos mais recentes
        if (historicoCard.scrollHeight > historicoCard.clientHeight) {
          historicoCard.scrollTop = historicoCard.scrollHeight;
        }
      }
    }

    // Run on load and resize (debounced)
    function rafEqualize(){ cancelAnimationFrame(rafEqualize._id||0); rafEqualize._id = requestAnimationFrame(equalizarAlturas); }
    window.addEventListener('resize', rafEqualize);
    // Wait a tick for layout
  setTimeout(equalizarAlturas, 50);
  setTimeout(equalizarAlturas, 250);
  // Após equalizar, garanta que a imagem cubra a área
  setTimeout(ensureAllAreasMinScale, 260);
    // E garante scroll ao fundo mesmo em telas pequenas, se houver overflow
    const historicoCardInit = document.getElementById('historico-card');
    if (historicoCardInit) {
      setTimeout(() => {
        if (historicoCardInit.scrollHeight > historicoCardInit.clientHeight) {
          historicoCardInit.scrollTop = historicoCardInit.scrollHeight;
        }
      }, 300);
    }
    // Also after images load
    document.querySelectorAll('.mapa-img').forEach(img => {
      if (img.complete) {
        ensureAllAreasMinScale();
        return;
      }
      img.addEventListener('load', function(){ rafEqualize(); ensureAllAreasMinScale(); });
    });
  // Inicializa controles e grade
  setupGridControls();
  updateAllGrids();
  ensureAllAreasMinScale();
  try { restoreTokenSizes(document); } catch(_) {}

    // ====== Ações do topo: selecionar/usar/adicionar mapa ======
    function setupTopbarMapActions(){
      const formMapa = document.getElementById('form-mapa');
      const selectMapaTop = document.getElementById('mapa_existente_top');
      if (!(formMapa && selectMapaTop)) return;
      // Garante campo hidden no form real
      let hidden = formMapa.querySelector('#mapa_existente_hidden');
      if (!hidden) {
        hidden = document.createElement('input');
        hidden.type = 'hidden';
        hidden.name = 'mapa_existente';
        hidden.id = 'mapa_existente_hidden';
        formMapa.prepend(hidden);
      }

      const btnUsar = document.getElementById('btn-usar-mapa');
      function syncSelectToForm() { hidden.value = selectMapaTop.value || ''; }
      if (btnUsar) {
        // Remove listeners anteriores clonando o nó
        const clone = btnUsar.cloneNode(true);
        btnUsar.parentNode.replaceChild(clone, btnUsar);
        clone.addEventListener('click', function() {
          syncSelectToForm();
          if (!hidden.value) { alert('Selecione um mapa existente.'); return; }
          let flag = formMapa.querySelector('input[name="usar_existente"]');
          if (!flag) { flag = document.createElement('input'); flag.type = 'hidden'; flag.name = 'usar_existente'; flag.value = '1'; formMapa.appendChild(flag); }
          formMapa.submit();
        });
      }
    }
  // Bind inicial
    setupTopbarMapActions();
  ajaxifyInteractionForms();
  });

  function drag(event, id) {
    event.dataTransfer.setData("tokenId", id);
  }

  document.addEventListener("DOMContentLoaded", function() {
    document.querySelectorAll("[id^='mapa-area-']").forEach(function(mapaArea) {
      mapaArea.addEventListener("dragover", function(e) { e.preventDefault(); });
      mapaArea.addEventListener("drop", function(e) {
        e.preventDefault();
        const tokenId = e.dataTransfer.getData("tokenId");
  const canvas = mapaArea.querySelector('.mapa-canvas') || mapaArea;
  const rect = canvas.getBoundingClientRect();
        const scale = parseFloat(mapaArea.dataset.scale || '1');
        const tokenEl = document.getElementById('token-' + tokenId);
        const tokenSize = tokenEl ? parseFloat(getComputedStyle(tokenEl).width) || 40 : 40;
        const half = tokenSize / 2;
        let x = (e.clientX - rect.left - half) / scale;
        let y = (e.clientY - rect.top - half) / scale;
        // Clamp to image bounds
        const img = canvas.querySelector('.mapa-img');
        const baseW = img ? (img.naturalWidth || img.clientWidth) : 0;
        const baseH = img ? (img.naturalHeight || img.clientHeight) : 0;
        if (baseW && baseH) {
          x = Math.max(0, Math.min(baseW - tokenSize, x));
          y = Math.max(0, Math.min(baseH - tokenSize, y));
        }
  if (window.gridEnabled && window.gridEnabled()) { const snapped = window.applyGridSnap ? window.applyGridSnap(x, y) : {x, y}; x = snapped.x; y = snapped.y; }
        fetch(`/combate/atualizar-posicao-token/${tokenId}/`, {
          method: "POST",
          headers: {
            "X-CSRFToken": "{{ csrf_token }}",
            "Content-Type": "application/json"
          },
          credentials: 'same-origin',
          body: JSON.stringify({x, y})
        }).then(() => {
          const token = document.getElementById("token-" + tokenId);
          token.style.left = x + "px";
          token.style.top = y + "px";
        });
      });
      // Bind per-token Ctrl+wheel resize on initial load as well
      mapaArea.querySelectorAll('.mapa-token').forEach(token => {
        if (token.dataset.wheelResized) return;
        token.addEventListener('wheel', function(e){
          if (!e.ctrlKey) return;
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();
          const cs = getComputedStyle(token);
          const cur = parseFloat(cs.width) || 40;
          const dir = e.deltaY > 0 ? -1 : 1;
          const factor = dir > 0 ? 1.1 : 1/1.1;
          let next = +(cur * factor).toFixed(2);
          const min = 20, max = 120;
          next = Math.max(min, Math.min(max, next));
          token.style.width = next + 'px';
          token.style.height = next + 'px';
          try { persistTokenSize(token); } catch(_) {}
          try {
            const id = (token.id || '').replace('token-','');
            fetch(`/combate/atualizar-posicao-token/${id}/`, {
              method: 'POST',
              headers: { 'X-CSRFToken': '{{ csrf_token }}', 'Content-Type': 'application/json' },
              credentials: 'same-origin',
              body: JSON.stringify({ size: next })
            }).catch(()=>{});
          } catch(_) {}
        }, { passive: false });
        token.dataset.wheelResized = '1';
        try { restoreTokenSize(token); } catch(_) {}
      });
      // Initialize zoom controls on DOMContentLoaded as well (outside scroll area)
      const wrapper = mapaArea.closest('.mapa-wrapper') || mapaArea.parentElement;
      const zoomBar = wrapper ? wrapper.querySelector('.mapa-zoom') : null;
      const canvas = mapaArea.querySelector('.mapa-canvas');
      if (zoomBar && canvas) {
        zoomBar.querySelectorAll('button[data-zoom]').forEach(btn => {
          // Remove previous listeners by cloning (initial load safe too)
          const cloned = btn.cloneNode(true);
          btn.replaceWith(cloned);
          cloned.addEventListener('click', function(){
            const action = this.getAttribute('data-zoom');
            let scale = parseFloat(mapaArea.dataset.scale || '1');
            if (action === 'in') scale = +(scale * 1.1).toFixed(3);
            else if (action === 'out') scale = +(scale / 1.1).toFixed(3);
            else scale = 1;
            // Inline setScale with dynamic min and bounds
            const setScaleLocal = (newScale)=>{
              const img = canvas.querySelector('.mapa-img');
              const baseW = img.naturalWidth || img.clientWidth;
              const baseH = img.naturalHeight || img.clientHeight;
              const areaW = mapaArea.clientWidth || 1;
              const areaH = mapaArea.clientHeight || 1;
              const fitW = areaW / (baseW || areaW);
              const fitH = areaH / (baseH || areaH);
              // Permite upscaling no cálculo de escala mínima
              const minScale = Math.max(fitW, fitH);
              const maxScale = 3;
              newScale = Math.max(minScale, Math.min(maxScale, newScale));
              mapaArea.dataset.scale = String(newScale);
              canvas.style.transform = `scale(${newScale})`;
              canvas.style.minWidth = (baseW * newScale) + 'px';
              canvas.style.minHeight = (baseH * newScale) + 'px';
              if (window.updateGridForArea) { window.updateGridForArea(mapaArea); }
            };
            setScaleLocal(scale);
          });
        });
      }
      // Panning bind on initial load as well
      (function bindPanInit(){
        if (!window._mapPanKeyBound) {
          window._mapSpacePressed = false;
          window.addEventListener('keydown', (ev)=>{ if (ev.code === 'Space') { window._mapSpacePressed = true; ev.preventDefault(); } }, { capture:true });
          window.addEventListener('keyup', (ev)=>{ if (ev.code === 'Space') { window._mapSpacePressed = false; ev.preventDefault(); } }, { capture:true });
          window._mapPanKeyBound = true;
        }
        if (!mapaArea.dataset.panBound) {
          let panning = false, startX = 0, startY = 0, startL = 0, startT = 0;
          function clampScrollToBounds() {
            const canvas = mapaArea.querySelector('.mapa-canvas');
            const img = canvas ? canvas.querySelector('.mapa-img') : null;
            if (!img) return;
            const scale = parseFloat(mapaArea.dataset.scale || '1');
            const baseW = img.naturalWidth || img.clientWidth || 0;
            const baseH = img.naturalHeight || img.clientHeight || 0;
            const maxX = Math.max(0, baseW * scale - mapaArea.clientWidth);
            const maxY = Math.max(0, baseH * scale - mapaArea.clientHeight);
            if (mapaArea.scrollLeft > maxX) mapaArea.scrollLeft = maxX;
            if (mapaArea.scrollTop > maxY) mapaArea.scrollTop = maxY;
            if (mapaArea.scrollLeft < 0) mapaArea.scrollLeft = 0;
            if (mapaArea.scrollTop < 0) mapaArea.scrollTop = 0;
          }
          function onMove(ev){ if (!panning) return; const dx = ev.clientX - startX; const dy = ev.clientY - startY; mapaArea.scrollLeft = startL - dx; mapaArea.scrollTop = startT - dy; clampScrollToBounds(); }
          function endPan(){ if (!panning) return; panning = false; mapaArea.classList.remove('panning'); window.removeEventListener('mousemove', onMove, true); window.removeEventListener('mouseup', endPan, true); }
          mapaArea.addEventListener('mousedown', function(ev){ const isMiddle = ev.button === 1; const isSpaceDrag = ev.button === 0 && window._mapSpacePressed; if (!isMiddle && !isSpaceDrag) return; ev.preventDefault(); ev.stopPropagation(); panning = true; startX = ev.clientX; startY = ev.clientY; startL = mapaArea.scrollLeft; startT = mapaArea.scrollTop; mapaArea.classList.add('panning'); window.addEventListener('mousemove', onMove, true); window.addEventListener('mouseup', endPan, true); }, { capture:true });
          mapaArea.addEventListener('dragstart', function(ev){ if (window._mapSpacePressed) { ev.preventDefault(); ev.stopImmediatePropagation(); } }, true);
          mapaArea.dataset.panBound = '1';
        }
      })();

      // Wheel handler on initial bind as well
      if (!mapaArea.dataset.wheelBound) {
        mapaArea.addEventListener('wheel', function(e){
          if (!e.ctrlKey) return;
          e.preventDefault();
          let scale = parseFloat(mapaArea.dataset.scale || '1');
          const dir = e.deltaY > 0 ? -1 : 1;
          const factor = dir > 0 ? 1.1 : 1/1.1;
          scale = +(scale * factor).toFixed(3);
          const img = canvas.querySelector('.mapa-img');
          const baseW = img.naturalWidth || img.clientWidth;
          const baseH = img.naturalHeight || img.clientHeight;
          const areaW = mapaArea.clientWidth || 1;
          const areaH = mapaArea.clientHeight || 1;
          const fitW = areaW / (baseW || areaW);
          const fitH = areaH / (baseH || areaH);
          // Ao fazer zoom com a roda, mantenha a escala mínima permitindo upscaling
          const minScale = Math.max(fitW, fitH);
          const maxScale = 3;
          const oldScale = parseFloat(mapaArea.dataset.scale || '1');
          // Clamp scale to dynamic bounds
          scale = Math.max(minScale, Math.min(maxScale, scale));
          const areaRect = mapaArea.getBoundingClientRect();
          const pointerX = e.clientX - areaRect.left;
          const pointerY = e.clientY - areaRect.top;
          canvas.style.transform = `scale(${scale})`;
          canvas.style.minWidth = (baseW * scale) + 'px';
          canvas.style.minHeight = (baseH * scale) + 'px';
          mapaArea.dataset.scale = String(scale);
          const sx = mapaArea.scrollLeft;
          const sy = mapaArea.scrollTop;
          const nx = (sx + pointerX) * (scale / oldScale) - pointerX;
          const ny = (sy + pointerY) * (scale / oldScale) - pointerY;
          const maxScrollX = Math.max(0, mapaArea.scrollWidth - mapaArea.clientWidth);
          const maxScrollY = Math.max(0, mapaArea.scrollHeight - mapaArea.clientHeight);
          mapaArea.scrollLeft = Math.min(maxScrollX, Math.max(0, nx));
          mapaArea.scrollTop = Math.min(maxScrollY, Math.max(0, ny));
        }, { passive: false });
        mapaArea.dataset.wheelBound = '1';
      }
      // Clamp scroll on initial load as well
      if (!mapaArea.dataset.scrollBound) {
        mapaArea.addEventListener('scroll', function(){
          const canvas = mapaArea.querySelector('.mapa-canvas');
          const img = canvas ? canvas.querySelector('.mapa-img') : null;
          if (!img) return;
          const scale = parseFloat(mapaArea.dataset.scale || '1');
          const baseW = img.naturalWidth || img.clientWidth || 0;
          const baseH = img.naturalHeight || img.clientHeight || 0;
          const maxX = Math.max(0, baseW * scale - mapaArea.clientWidth);
          const maxY = Math.max(0, baseH * scale - mapaArea.clientHeight);
          if (mapaArea.scrollLeft > maxX) mapaArea.scrollLeft = maxX;
          if (mapaArea.scrollTop > maxY) mapaArea.scrollTop = maxY;
          if (mapaArea.scrollLeft < 0) mapaArea.scrollLeft = 0;
          if (mapaArea.scrollTop < 0) mapaArea.scrollTop = 0;
        }, { passive: true });
        mapaArea.dataset.scrollBound = '1';
      }
    });
  });
</script>

{% endblock %}

