{% extends 'base.html' %}
{% load static %}

{% block content %}
<div id="combate-content" class="combate-detalhes-center">
  <!-- Topo: info de turno + ações globais -->
  <div class="turno-topbar combate-card">
    <div class="turno-topbar-row">
      <div class="turno-topbar-info">
      {% if turno_ativo %}
        <strong>Turno:</strong> {{ turno_ativo.personagem.nome }}
      {% else %}
        <strong>Sem turno ativo</strong>
      {% endif %}
      </div>
      <div class="turno-topbar-actions">
      {% if not turno_ativo and combate.ativo %}
        <form method="post" action="{% url 'iniciar_turno' combate.id %}" class="inline-form">
          {% csrf_token %}
          <button type="submit" class="btn btn-sm">Iniciar Turno</button>
        </form>
      {% endif %}
      {% if turno_ativo %}
        <form method="post" action="{% url 'avancar_turno' combate.id %}" class="inline-form">
          {% csrf_token %}
          <button type="submit" formnovalidate class="btn btn-sm">Avançar Turno</button>
        </form>
      {% endif %}
      {% if combate.ativo %}
        <form method="post" action="{% url 'finalizar_combate' combate.id %}" class="inline-form">
          {% csrf_token %}
          <button type="submit" class="btn btn-sm btn-danger" formnovalidate>Finalizar Combate</button>
        </form>
        {% if combate.sala.game_master == user %}
        <form method="post" action="{% url 'limpar_historico' combate.id %}" class="inline-form" onsubmit="return confirm('Limpar todo o histórico de ataques? Esta ação não pode ser desfeita.');">
          {% csrf_token %}
          <button type="submit" class="btn btn-sm" formnovalidate>Limpar Histórico</button>
        </form>
        {% endif %}
      {% endif %}
      </div>
    </div>
  {# Moved map selection next to the map title in the right column #}
  </div>

  <!-- Grid 1/3 - 2/3 -->
  <div class="combate-layout-grid">
    <!-- Coluna esquerda: Ações + Histórico -->
  <div class="combate-col-left">

      <h3 class="combate-section-title">Ações de</h3>
      <div class="acao-top-row">
        <select id="personagem_acao" name="personagem_acao" form="form-ataque" class="select-md">
          {% if combate.sala.game_master == user %}
            {% for p in participantes %}
              <option value="{{ p.id }}" data-personagem-id="{{ p.personagem.id }}">{{ p.display_nome|default:p.personagem.nome }}</option>
            {% endfor %}
          {% else %}
            {% for p in participantes %}
              {% if p.personagem.usuario == user %}
                <option value="{{ p.id }}" data-personagem-id="{{ p.personagem.id }}">{{ p.display_nome|default:p.personagem.nome }}</option>
              {% endif %}
            {% endfor %}
          {% endif %}
        </select>
        <form method="post" action="{% url 'realizar_ataque' combate.id %}" id="form-d20" class="inline-form">
          {% csrf_token %}
          <input type="hidden" name="personagem_acao" id="personagem_acao_hidden_d20" value="{{ participantes.0.id }}">
          <button type="submit" name="rolar_d20" value="1" class="btn btn-sm">Rolar d20</button>
        </form>
      </div>

      <form method="post" action="{% url 'realizar_ataque' combate.id %}" id="form-ataque" class="combate-card ataque-card">
        {% csrf_token %}
  <input type="hidden" name="personagem_acao" id="personagem_acao_hidden" value="{{ participantes.0.id }}">
  <!-- Hidden extras para manter sincronização existente -->
  <input type="hidden" id="personagem_acao_hidden_pericia" value="{{ participantes.0.id }}">
  <input type="hidden" id="personagem_acao_hidden_caracteristica" value="{{ participantes.0.id }}">

        <label for="alvo">Alvo(s):</label>
        <small id="alvo_hint" class="form-hint" style="display:block; margin:-4px 0 6px; color:#666; font-size:12px;">
          Segure Ctrl (Windows/Linux) ou Cmd (macOS) para selecionar múltiplos; use Shift para selecionar intervalos.
        </small>
        <select id="alvo" name="alvo_id" multiple required size="4" class="multiselect-alvos" aria-describedby="alvo_hint" title="Segure Ctrl (Windows/Linux) ou Cmd (macOS) para seleção múltipla; Shift para intervalos.">
          {% for p in participantes %}
            <option value="{{ p.id }}">{{ p.display_nome|default:p.personagem.nome }}</option>
          {% endfor %}
        </select>

        <div class="acao-row">
          <label for="poder">Poder:</label>
          <select name="poder_id" id="poder" required class="select-md">
            {% for poder in poderes_disponiveis %}
              <option value="{{ poder.id }}">{{ poder.nome }}</option>
            {% empty %}
              <option disabled>Nenhum poder disponível</option>
            {% endfor %}
          </select>
          <button type="submit" class="btn btn-sm">Rolar</button>
        </div>

        <div class="acao-row">
          <label for="pericia_rolar">Perícia:</label>
          <select name="pericia" id="pericia_rolar" class="select-md">
            <option value="">-- Selecione uma perícia --</option>
            {% for pericia in pericias %}
              <option value="{{ pericia }}">{{ pericia|capfirst }}</option>
            {% endfor %}
          </select>
          <button type="submit" name="rolar_pericia" value="1" class="btn btn-sm" formnovalidate>Rolar</button>
        </div>

        <div class="acao-row">
          <label for="caracteristica_rolar">Característica:</label>
          <select name="caracteristica" id="caracteristica_rolar" class="select-md">
            <option value="">-- Selecione uma característica --</option>
            {% for c in caracteristicas %}
              <option value="{{ c }}">{{ c|capfirst }}</option>
            {% endfor %}
          </select>
          <button type="submit" name="rolar_caracteristica" value="1" class="btn btn-sm" formnovalidate>Rolar</button>
        </div>
      </form>

      

  <h3 class="combate-section-title">Histórico de Ataques</h3>
  <div id="historico-card" class="combate-card">
  <ul class="turnos-list">
        {% for turno in turnos %}
          <li class="turno-item {% if turno.ativo %}ativo{% endif %}">
            <div class="turno-header">
              <strong>Rodada {{ turno.ordem }}</strong>
              <span class="turno-data">{{ turno.criado_em|date:"d/m/Y H:i" }}</span>
              {% if turno.ativo %}<span class="status-badge atual">Ativo</span>{% endif %}
            </div>
            <div class="turno-desc">{{ turno.descricao|safe }}</div>
          </li>
        {% empty %}
          <li class="turno-item vazio"><em>Nenhum ataque registrado ainda.</em></li>
        {% endfor %}
  </ul>
  </div>
    </div>

    <!-- Coluna direita: Mapa + Status participantes -->
    <div class="combate-col-right">
      <div class="mapa-header-row">
        <h3 class="combate-section-title" style="margin:0">Mapa do Combate</h3>
        {% if combate.sala.game_master == user %}
        <div class="mapa-header-actions">
          <label for="mapa_existente_top" class="sr-only">Selecionar mapa</label>
          <select id="mapa_existente_top" class="select-sm" title="Selecionar mapa">
            <option value="">– mapa –</option>
            {% for mapa in mapas_globais %}
              <option value="{{ mapa.id }}">{{ mapa.nome }}</option>
            {% endfor %}
          </select>
          <button type="button" id="btn-usar-mapa" class="btn btn-sm">Usar</button>
          <a href="{% url 'adicionar_mapa' combate.id %}" target="_blank" rel="noopener" id="btn-add-mapa-link" class="btn btn-sm">Novo</a>
          <!-- Grade opcional para precisão de movimento -->
          <label style="margin-left:8px; display:inline-flex; align-items:center; gap:4px;">
            <input type="checkbox" id="grid-enable"> Grade
          </label>
          <select id="grid-size" class="select-sm" title="Tamanho da grade" style="margin-left:4px;">
            <option value="20">20px</option>
            <option value="40" selected>40px</option>
            <option value="60">60px</option>
          </select>
        </div>
        {% endif %}
      </div>
      {% if combate.mapas.all %}
        {% for mapa in combate.mapas.all %}
          <div class="mapa-wrapper">
            <div id="mapa-area-{{ mapa.id }}" class="mapa-area" data-scale="1">
              <div class="mapa-canvas">
  <img src="{{ mapa.imagem.url }}" alt="{{ mapa.nome }}" class="mapa-img" title="{{ mapa.imagem.url }}" data-fallback="{% static 'img/mapa_placeholder.svg' %}" onerror="this.onerror=null;this.src=this.dataset.fallback;">
  {% if combate.sala.game_master == user %}
    <div class="mapa-debug-url" style="font-size:12px;color:#888;margin-top:4px;word-break:break-all;">URL: {{ mapa.imagem.url }}</div>
  {% endif %}
            {% for posicao in posicoes %}
              {% if posicao.mapa.id == mapa.id %}
                {% if posicao.participante.personagem.foto %}
         <img src="{{ posicao.participante.personagem.foto.url }}" title="{{ posicao.participante.personagem.foto.url }}"
           id="token-{{ posicao.id }}"
           class="mapa-token"
           style="left:{{ posicao.x }}px; top:{{ posicao.y }}px;"
           draggable="true"
           ondragstart="drag(event, {{ posicao.id }})">
                {% else %}
         <div id="token-{{ posicao.id }}" class="mapa-token token-fallback"
           style="left:{{ posicao.x }}px; top:{{ posicao.y }}px;"
           draggable="true"
           ondragstart="drag(event, {{ posicao.id }})">
                    {{ posicao.participante.personagem.nome|slice:"0:2"|upper }}
                  </div>
                {% endif %}
              {% endif %}
            {% endfor %}
              </div>
            </div>
            <div class="mapa-zoom">
              <button type="button" class="btn btn-sm" data-zoom="out">−</button>
              <button type="button" class="btn btn-sm" data-zoom="reset">Reset</button>
              <button type="button" class="btn btn-sm" data-zoom="in">+</button>
            </div>
            {% if combate.sala.game_master == user %}
              <form method="post" action="{% url 'remover_mapa' combate.id mapa.id %}" class="mapa-remover-form">
                {% csrf_token %}
                <button type="submit" class="btn btn-sm btn-danger">Remover Mapa</button>
              </form>
            {% endif %}
          </div>
        {% endfor %}
      {% endif %}



      {% if combate.sala.game_master == user %}
        {% if combate.mapas.all|length == 0 %}
        <form method="post" enctype="multipart/form-data" action="{% url 'adicionar_mapa' combate.id %}" class="combate-card mapa-upload-form" id="form-mapa">
          {% csrf_token %}
          <input type="hidden" name="mapa_existente" id="mapa_existente_hidden" value="">
          <strong>Envie um Mapa:</strong>
          {{ form.as_p }}
        </form>
        {% else %}
        <!-- Form oculto apenas para permitir a ação "Usar Selecionado" do topo -->
        <form method="post" action="{% url 'adicionar_mapa' combate.id %}" id="form-mapa" style="display:none">
          {% csrf_token %}
          <input type="hidden" name="mapa_existente" id="mapa_existente_hidden" value="">
        </form>
        {% endif %}
      {% endif %}

      <div class="mapa-header-row">
        <h3 class="combate-section-title" style="margin:0">Status dos Participantes</h3>
        {% if personagens_disponiveis %}
        <form method="post" action="{% url 'adicionar_participante' combate.id %}" class="combate-inline-form form-add-participante">
          {% csrf_token %}
          <label for="novo_participante" class="sr-only">Adicionar personagem</label>
          <select name="personagem_id" id="novo_participante" required class="select-sm" title="Adicionar personagem">
            {% for personagem in personagens_disponiveis %}
              <option value="{{ personagem.id }}">{{ personagem.nome }} ({{ personagem.usuario.username }})</option>
            {% endfor %}
          </select>
          <button type="submit" class="btn btn-sm">Adicionar</button>
        </form>
        {% endif %}
        {% if combate.sala.game_master == user and npcs_disponiveis %}
        <form method="post" action="{% url 'adicionar_npc_participante' combate.id %}" class="combate-inline-form form-add-participante">
          {% csrf_token %}
          <label for="novo_npc" class="sr-only">Adicionar NPC</label>
          <select name="npc_id" id="novo_npc" required class="select-sm" title="Adicionar NPC">
            {% for npc in npcs_disponiveis %}
              <option value="{{ npc.id }}">{{ npc.nome }}</option>
            {% endfor %}
          </select>
          <button type="submit" class="btn btn-sm">Adicionar NPC</button>
        </form>
        {% endif %}
      </div>
      <div id="status-card" class="combate-card">
        {% include 'combate/_tabela_participantes.html' %}
      </div>
    </div>
  </div>

  <script>
  // Função reutilizável para sincronizar selects de personagem e poderes (chamada após partial refresh)
  function bindPersonagemAcaoSync() {
    const select = document.getElementById('personagem_acao');
    const poderSelect = document.getElementById('poder');
    if (!select) return;
    function syncPersonagemAcao() {
      const val = select.value; // participante id
      const selectedOpt = select.options[select.selectedIndex];
      const personagemId = selectedOpt ? selectedOpt.getAttribute('data-personagem-id') : '';
      const h1 = document.getElementById('personagem_acao_hidden');
      const h2 = document.getElementById('personagem_acao_hidden_pericia');
      const h3 = document.getElementById('personagem_acao_hidden_caracteristica');
      const h4 = document.getElementById('personagem_acao_hidden_d20');
      if (h1) h1.value = val; if (h2) h2.value = val; if (h3) h3.value = val; if (h4) h4.value = val;
      if (poderSelect) {
        fetch('/combate/poderes-personagem-ajax/?personagem_id=' + personagemId)
          .then(resp => resp.json())
          .then(data => {
            poderSelect.innerHTML = '';
            if (data.poderes && data.poderes.length > 0) {
              data.poderes.forEach(function(p) {
                const opt = document.createElement('option');
                opt.value = p.id;
                opt.textContent = p.nome;
                poderSelect.appendChild(opt);
              });
            } else {
              const opt = document.createElement('option');
              opt.disabled = true;
              opt.textContent = 'Nenhum poder disponível';
              poderSelect.appendChild(opt);
            }
          });
      }
    }
    // Evita listeners duplicados trocando o nó
    const newSelect = select.cloneNode(true);
    select.replaceWith(newSelect);
    newSelect.addEventListener('change', syncPersonagemAcao);
    // Garante um valor selecionado válido
    if (newSelect.options.length && newSelect.selectedIndex < 0) newSelect.selectedIndex = 0;
    syncPersonagemAcao();
  }
  document.addEventListener('DOMContentLoaded', bindPersonagemAcaoSync);
  </script>

  
</div>

<script>
  document.addEventListener('DOMContentLoaded', function() {
    const combateId = '{{ combate.id }}';
    const wsScheme = window.location.protocol === 'https:' ? 'wss' : 'ws';
    const wsPath = `${wsScheme}://${window.location.host}/ws/combate/${combateId}/`;
    const combateSocket = new WebSocket(wsPath);

    // Persistência de preferências da grade por combate
    const GRID_ENABLED_KEY = `combate:${combateId}:gridEnabled`;
    const GRID_SIZE_KEY = `combate:${combateId}:gridSize`;
    function persistGridState() {
      const cb = document.getElementById('grid-enable');
      const sel = document.getElementById('grid-size');
      if (cb) localStorage.setItem(GRID_ENABLED_KEY, cb.checked ? '1' : '0');
      if (sel) localStorage.setItem(GRID_SIZE_KEY, sel.value || '40');
    }
    function restoreGridStateIfNeeded() {
      const cb = document.getElementById('grid-enable');
      const sel = document.getElementById('grid-size');
      const savedEnabled = localStorage.getItem(GRID_ENABLED_KEY);
      const savedSize = localStorage.getItem(GRID_SIZE_KEY);
      if (cb && !cb.dataset.restored && savedEnabled !== null) {
        cb.checked = savedEnabled === '1';
        cb.dataset.restored = '1';
      }
      if (sel && !sel.dataset.restored && savedSize) {
        sel.value = savedSize;
        sel.dataset.restored = '1';
      }
    }


    // ====== Grade (grid) opcional para melhorar precisão com zoom ======
  function gridEnabled(){
      const cb = document.getElementById('grid-enable');
      return !!(cb && cb.checked);
    }
    function getGridSize(){
      const sel = document.getElementById('grid-size');
      const v = sel && parseInt(sel.value, 10);
      return Number.isFinite(v) && v > 4 ? v : 40;
    }
    function applyGridSnap(x, y){
      const cell = getGridSize();
      x = Math.round(x / cell) * cell;
      y = Math.round(y / cell) * cell;
      return {x, y};
    }
    function updateGridForArea(mapaArea){
      const canvas = mapaArea && mapaArea.querySelector('.mapa-canvas');
      if (!canvas) return;
      if (!gridEnabled()){
        canvas.style.backgroundImage = '';
        canvas.style.backgroundSize = '';
        canvas.style.backgroundPosition = '';
        return;
      }
      const scale = parseFloat(mapaArea.dataset.scale || '1');
      const cell = getGridSize();
      const cellPx = Math.max(4, Math.round(cell * scale));
      // Linhas de 1px cinza claro; duas grades (x e y)
      const line = 'rgba(0,0,0,0.12)';
      canvas.style.backgroundImage = `
        repeating-linear-gradient(to right, ${line} 0, ${line} 1px, transparent 1px, transparent ${cellPx}px),
        repeating-linear-gradient(to bottom, ${line} 0, ${line} 1px, transparent 1px, transparent ${cellPx}px)
      `;
      canvas.style.backgroundSize = `${cellPx}px ${cellPx}px`;
      canvas.style.backgroundPosition = '0 0';
    }
    function updateAllGrids(){
      document.querySelectorAll("[id^='mapa-area-']").forEach(updateGridForArea);
    }
    function setupGridControls(){
      const cb = document.getElementById('grid-enable');
      const sel = document.getElementById('grid-size');
      // Restaura estado salvo (se houver)
      restoreGridStateIfNeeded();
      if (cb && !cb.dataset.bound){
        cb.addEventListener('change', () => { persistGridState(); updateAllGrids(); });
        cb.dataset.bound = '1';
      }
      if (sel && !sel.dataset.bound){
        sel.addEventListener('change', () => { persistGridState(); updateAllGrids(); });
        sel.dataset.bound = '1';
      }
    }

  // Torna helpers acessíveis globalmente para outros blocos/scripts
  window.gridEnabled = gridEnabled;
  window.getGridSize = getGridSize;
  window.applyGridSnap = applyGridSnap;
  window.updateGridForArea = updateGridForArea;
  window.updateAllGrids = updateAllGrids;
  window.setupGridControls = setupGridControls;

    // Utilitários para refresh parcial
    async function fetchPageDOM() {
      const resp = await fetch(window.location.href, { cache: 'no-store' });
      const html = await resp.text();
      const parser = new DOMParser();
      return parser.parseFromString(html, 'text/html');
    }
  async function refreshSelectors(selectors) {
      try {
        // Garante que a preferência atual da grade não se perca durante o refresh
        persistGridState();
        const doc = await fetchPageDOM();
        selectors.forEach(sel => {
          const target = document.querySelector(sel);
          const fresh = doc.querySelector(sel);
          if (target && fresh) target.replaceWith(fresh);
        });
        // Reaplica comportamentos após substituições
    rafEqualize();
        // Scroll historico para o fim
        const historico = document.getElementById('historico-card');
        if (historico && historico.scrollHeight > historico.clientHeight) historico.scrollTop = historico.scrollHeight;
  // Rebind drag & drop após trocas da coluna direita
        rebindDragDrop();
  // Rebind ações do topo se a barra de turno foi trocada
    setupTopbarMapActions();
  // Rebind e atualizar grade
  setupGridControls();
  updateAllGrids();
  // Rebind dos formulários para evitar navegação
  ajaxifyInteractionForms();
  // Rebind dos selects de personagem/ataque, para atualizar poderes
  bindPersonagemAcaoSync();
      } catch (err) {
        console.warn('Refresh parcial falhou, mantendo página:', err);
      }
    }
    function rebindDragDrop(){
      document.querySelectorAll("[id^='mapa-area-']").forEach(function(mapaArea) {
        mapaArea.addEventListener('dragover', function(e){ e.preventDefault(); });
        mapaArea.addEventListener('drop', function(e){
          e.preventDefault();
          const tokenId = e.dataTransfer.getData('tokenId');
          const canvas = mapaArea.querySelector('.mapa-canvas') || mapaArea;
          const rect = canvas.getBoundingClientRect();
          const scale = parseFloat(mapaArea.dataset.scale || '1');
          const tokenEl = document.getElementById('token-' + tokenId);
          const tokenSize = tokenEl ? parseFloat(getComputedStyle(tokenEl).width) || 40 : 40;
          const half = tokenSize / 2;
          let x = (e.clientX - rect.left - half) / scale;
          let y = (e.clientY - rect.top - half) / scale;
          // Clamp to image bounds (pre-transform coordinates)
          const img = canvas.querySelector('.mapa-img');
          const baseW = img ? (img.naturalWidth || img.clientWidth) : 0;
          const baseH = img ? (img.naturalHeight || img.clientHeight) : 0;
          if (baseW && baseH) {
            x = Math.max(0, Math.min(baseW - tokenSize, x));
            y = Math.max(0, Math.min(baseH - tokenSize, y));
          }
          // Snap opcional à grade
          if (gridEnabled()) { const snapped = applyGridSnap(x, y); x = snapped.x; y = snapped.y; }
          fetch(`/combate/atualizar-posicao-token/${tokenId}/`, {
            method: 'POST',
            headers: { 'X-CSRFToken': '{{ csrf_token }}', 'Content-Type': 'application/json' },
            credentials: 'same-origin',
            body: JSON.stringify({x,y})
          }).then(() => {
            const token = document.getElementById('token-' + tokenId);
            if (token) { token.style.left = x + 'px'; token.style.top = y + 'px'; }
          });
        });

        // Per-token resize with Ctrl + wheel over the token
        function bindTokenWheelResize() {
          mapaArea.querySelectorAll('.mapa-token').forEach(token => {
            if (token.dataset.wheelResized) return;
            token.addEventListener('wheel', function(e){
              if (!e.ctrlKey) return; // only when holding Ctrl
              e.preventDefault();
              e.stopPropagation();
              e.stopImmediatePropagation();
              const cs = getComputedStyle(token);
              const cur = parseFloat(cs.width) || 40;
              const dir = e.deltaY > 0 ? -1 : 1;
              const factor = dir > 0 ? 1.1 : 1/1.1;
              let next = +(cur * factor).toFixed(2);
              const min = 20, max = 120;
              next = Math.max(min, Math.min(max, next));
              token.style.width = next + 'px';
              token.style.height = next + 'px';
            }, { passive: false });
            token.dataset.wheelResized = '1';
          });
        }
        bindTokenWheelResize();

        // Helper to set scale, expand scrollable area, and keep pointer focus (if pivot provided)
        function setScale(newScale, pivotEvent){
          const canvas = mapaArea.querySelector('.mapa-canvas');
          const img = canvas ? canvas.querySelector('.mapa-img') : null;
          if (!canvas || !img) return;
          const oldScale = parseFloat(mapaArea.dataset.scale || '1');
          const rect = canvas.getBoundingClientRect();
          // Base (natural) size
          const baseW = img.naturalWidth || img.clientWidth || rect.width;
          const baseH = img.naturalHeight || img.clientHeight || rect.height;
          // Container size and dynamic min scale to keep map covering the viewport
          const areaW = mapaArea.clientWidth || 1;
          const areaH = mapaArea.clientHeight || 1;
          const fitW = areaW / (baseW || areaW);
          const fitH = areaH / (baseH || areaH);
          const minScale = Math.min(1, Math.max(fitW, fitH));
          const maxScale = 3;
          newScale = Math.max(minScale, Math.min(maxScale, newScale));
          // Apply transform and enlarge scrollable box so scrollbars match zoom
          mapaArea.dataset.scale = String(newScale);
          canvas.style.transform = `scale(${newScale})`;
          canvas.style.minWidth = (baseW * newScale) + 'px';
          canvas.style.minHeight = (baseH * newScale) + 'px';
          // Atualiza grade com novo zoom
          updateGridForArea(mapaArea);

          // Preserve focal point under cursor if event provided
          if (pivotEvent) {
            const areaRect = mapaArea.getBoundingClientRect();
            const pointerX = pivotEvent.clientX - areaRect.left;
            const pointerY = pivotEvent.clientY - areaRect.top;
            const sx = mapaArea.scrollLeft;
            const sy = mapaArea.scrollTop;
            const nx = (sx + pointerX) * (newScale / oldScale) - pointerX;
            const ny = (sy + pointerY) * (newScale / oldScale) - pointerY;
            const maxScrollX = Math.max(0, mapaArea.scrollWidth - mapaArea.clientWidth);
            const maxScrollY = Math.max(0, mapaArea.scrollHeight - mapaArea.clientHeight);
            mapaArea.scrollLeft = Math.min(maxScrollX, Math.max(0, nx));
            mapaArea.scrollTop = Math.min(maxScrollY, Math.max(0, ny));
          }
        }

        // Zoom controls (bar is outside the scrollable area, in the wrapper)
        const wrapper = mapaArea.closest('.mapa-wrapper') || mapaArea.parentElement;
        const zoomBar = wrapper ? wrapper.querySelector('.mapa-zoom') : null;
        const canvas = mapaArea.querySelector('.mapa-canvas');
        if (zoomBar && canvas) {
          zoomBar.querySelectorAll('button[data-zoom]').forEach(btn => {
            // Remove previous listeners by cloning (in case of rebinds)
            const cloned = btn.cloneNode(true);
            btn.replaceWith(cloned);
            cloned.addEventListener('click', function(){
              const action = this.getAttribute('data-zoom');
              let scale = parseFloat(mapaArea.dataset.scale || '1');
              if (action === 'in') scale = +(scale * 1.1).toFixed(3);
              else if (action === 'out') scale = +(scale / 1.1).toFixed(3);
              else scale = 1;
              setScale(scale);
            });
          });
        }

        // Clamp scroll so it never goes beyond the scaled image area
        if (!mapaArea.dataset.scrollBound) {
          mapaArea.addEventListener('scroll', function(){
            const canvas = mapaArea.querySelector('.mapa-canvas');
            const img = canvas ? canvas.querySelector('.mapa-img') : null;
            if (!img) return;
            const scale = parseFloat(mapaArea.dataset.scale || '1');
            const baseW = img.naturalWidth || img.clientWidth || 0;
            const baseH = img.naturalHeight || img.clientHeight || 0;
            const maxX = Math.max(0, baseW * scale - mapaArea.clientWidth);
            const maxY = Math.max(0, baseH * scale - mapaArea.clientHeight);
            if (mapaArea.scrollLeft > maxX) mapaArea.scrollLeft = maxX;
            if (mapaArea.scrollTop > maxY) mapaArea.scrollTop = maxY;
            if (mapaArea.scrollLeft < 0) mapaArea.scrollLeft = 0;
            if (mapaArea.scrollTop < 0) mapaArea.scrollTop = 0;
          }, { passive: true });
          mapaArea.dataset.scrollBound = '1';
        }

        // Panning: Middle mouse or Space + Left drag
        function clampScrollToBounds() {
          const canvas = mapaArea.querySelector('.mapa-canvas');
          const img = canvas ? canvas.querySelector('.mapa-img') : null;
          if (!img) return;
          const scale = parseFloat(mapaArea.dataset.scale || '1');
          const baseW = img.naturalWidth || img.clientWidth || 0;
          const baseH = img.naturalHeight || img.clientHeight || 0;
          const maxX = Math.max(0, baseW * scale - mapaArea.clientWidth);
          const maxY = Math.max(0, baseH * scale - mapaArea.clientHeight);
          if (mapaArea.scrollLeft > maxX) mapaArea.scrollLeft = maxX;
          if (mapaArea.scrollTop > maxY) mapaArea.scrollTop = maxY;
          if (mapaArea.scrollLeft < 0) mapaArea.scrollLeft = 0;
          if (mapaArea.scrollTop < 0) mapaArea.scrollTop = 0;
        }

        function bindPan(){
          if (!window._mapPanKeyBound) {
            window._mapSpacePressed = false;
            window.addEventListener('keydown', (ev)=>{ if (ev.code === 'Space') { window._mapSpacePressed = true; ev.preventDefault(); } }, { capture:true });
            window.addEventListener('keyup', (ev)=>{ if (ev.code === 'Space') { window._mapSpacePressed = false; ev.preventDefault(); } }, { capture:true });
            window._mapPanKeyBound = true;
          }
          if (mapaArea.dataset.panBound) return;
          let panning = false, startX = 0, startY = 0, startL = 0, startT = 0;
          function onMove(ev){
            if (!panning) return;
            const dx = ev.clientX - startX;
            const dy = ev.clientY - startY;
            mapaArea.scrollLeft = startL - dx;
            mapaArea.scrollTop = startT - dy;
            clampScrollToBounds();
          }
          function endPan(){
            if (!panning) return;
            panning = false;
            mapaArea.classList.remove('panning');
            window.removeEventListener('mousemove', onMove, true);
            window.removeEventListener('mouseup', endPan, true);
          }
          mapaArea.addEventListener('mousedown', function(ev){
            const isMiddle = ev.button === 1;
            const isSpaceDrag = ev.button === 0 && window._mapSpacePressed;
            if (!isMiddle && !isSpaceDrag) return;
            ev.preventDefault();
            ev.stopPropagation();
            panning = true;
            startX = ev.clientX; startY = ev.clientY;
            startL = mapaArea.scrollLeft; startT = mapaArea.scrollTop;
            mapaArea.classList.add('panning');
            window.addEventListener('mousemove', onMove, true);
            window.addEventListener('mouseup', endPan, true);
          }, { capture:true });
          // Prevent token drag when holding space
          mapaArea.addEventListener('dragstart', function(ev){ if (window._mapSpacePressed) { ev.preventDefault(); ev.stopImmediatePropagation(); } }, true);
          mapaArea.dataset.panBound = '1';
        }
        bindPan();

        // Ctrl + wheel zoom (once)
        if (!mapaArea.dataset.wheelBound) {
          mapaArea.addEventListener('wheel', function(e){
            if (!e.ctrlKey) return;
            e.preventDefault();
            let scale = parseFloat(mapaArea.dataset.scale || '1');
            const dir = e.deltaY > 0 ? -1 : 1; // up = zoom in
            const factor = dir > 0 ? 1.1 : 1/1.1;
            scale = +(scale * factor).toFixed(3);
            setScale(scale, e);
          }, { passive: false });
          mapaArea.dataset.wheelBound = '1';
        }
      });
    }

    // ====== AJAXify de formulários para evitar reload ======
    function bindAjax(form){
      if (!form || form.dataset.ajaxified === '1') return;
      form.addEventListener('submit', function(e){
        e.preventDefault();
        const submitter = e.submitter || null;
        let fd;
        try { fd = new FormData(form, submitter); }
        catch(_){ fd = new FormData(form); if (submitter && submitter.name) fd.append(submitter.name, submitter.value || '1'); }
        const btn = submitter || form.querySelector('button[type="submit"]');
        if (btn) btn.disabled = true;
        fetch(form.action, {
          method: 'POST',
          body: fd,
          headers: { 'X-Requested-With': 'XMLHttpRequest' },
          credentials: 'same-origin'
        }).finally(() => { if (btn) btn.disabled = false; });
      });
      form.dataset.ajaxified = '1';
    }
    function ajaxifyInteractionForms(){
      bindAjax(document.getElementById('form-d20'));
      bindAjax(document.getElementById('form-ataque'));
      document.querySelectorAll('.turno-topbar-actions form').forEach(bindAjax);
  document.querySelectorAll('.form-remover-participante').forEach(bindAjax);
  document.querySelectorAll('.form-add-participante').forEach(bindAjax);
    }

    combateSocket.onmessage = async function(e) {
      let payload = null;
      try { payload = JSON.parse(e.data); } catch(_) {}
      if (!payload || !payload.evento) {
        // Desconhecido: faça refresh leve dos principais blocos
        await refreshSelectors(['.turno-topbar', '#historico-card', '.combate-col-right']);
        return;
      }
      switch (payload.evento) {
        case 'token_move': {
          // Atualiza apenas o token informado, sem refresh de colunas
          const id = payload.posicao_id;
          const x = payload.x; const y = payload.y;
          const token = document.getElementById('token-' + id);
          if (token && Number.isFinite(x) && Number.isFinite(y)) {
            token.style.left = x + 'px';
            token.style.top = y + 'px';
          }
          break;
        }
        case 'rolagem': {
          // Acrescenta somente ao histórico
          const ativo = document.querySelector('.turnos-list .turno-item.ativo .turno-desc')
                        || document.querySelector('.turnos-list .turno-item:last-child .turno-desc');
          if (ativo) {
            const extra = document.createElement('div');
            extra.innerHTML = payload.descricao || '';
            // Preserva quebras de linha como HTML
            ativo.innerHTML = (ativo.innerHTML ? ativo.innerHTML + '<br>' : '') + extra.innerHTML;
            const historico = document.getElementById('historico-card');
            if (historico && historico.scrollHeight > historico.clientHeight) historico.scrollTop = historico.scrollHeight;
            // Garante atualização do status dos participantes sem recarregar a página inteira
            await refreshSelectors(['#status-card']);
          } else {
            await refreshSelectors(['#historico-card', '#status-card']);
          }
          break;
        }
        case 'limpar_historico': {
          await refreshSelectors(['.turno-topbar', '#historico-card', '#form-ataque']);
          break;
        }
  case 'adicionar_mapa':
  case 'remover_mapa': {
          await refreshSelectors(['.combate-col-right']);
          break;
        }
        case 'adicionar_participante':
        case 'remover_participante': {
          await refreshSelectors(['.combate-col-right', '#form-ataque']);
          break;
        }
        case 'iniciar_turno':
        case 'avancar_turno':
        case 'finalizar_combate': {
          await refreshSelectors(['.turno-topbar', '#historico-card', '#status-card']);
          break;
        }
        default: {
          await refreshSelectors(['.turno-topbar', '#historico-card', '.combate-col-right']);
        }
      }
    };

    combateSocket.onclose = function(e) {
      console.warn('WebSocket fechado.');
    };

    window.enviarMensagemCombate = function(msg) {
      combateSocket.send(msg);
    };

    // ====== Equalização de alturas (Mapa x Ações) e (Histórico x Status) ======
    function equalizarAlturas() {
      const isStacked = window.matchMedia('(max-width: 1000px)').matches;
      const acoesCard = document.getElementById('form-ataque');
      const acaoTopRow = document.querySelector('.acao-top-row');
      const mapaAreas = document.querySelectorAll('.mapa-area');
      const historicoCard = document.getElementById('historico-card');
      const statusCard = document.getElementById('status-card');

      const outerH = (el) => {
        if (!el) return 0;
        const cs = getComputedStyle(el);
        return el.offsetHeight + parseFloat(cs.marginTop || 0) + parseFloat(cs.marginBottom || 0);
      };

      // Reset when stacked
      if (isStacked) {
        mapaAreas.forEach(m => m.style.height = '');
        if (historicoCard) {
          historicoCard.style.height = '';
          historicoCard.style.maxHeight = '';
          historicoCard.style.overflowY = '';
        }
        return;
      }

      // Mapa do Combate = altura do bloco de Ações (linha do topo + card), incluindo margens
      if (mapaAreas.length) {
        const alvoAlt = outerH(acaoTopRow) + outerH(acoesCard);
        mapaAreas.forEach(m => m.style.height = Math.max(360, alvoAlt) + 'px');
      }

      // Histórico = mesma altura do Status; se maior, aplica scroll
      if (historicoCard && statusCard) {
        const statusAlt = statusCard.offsetHeight;
        historicoCard.style.height = statusAlt + 'px';
        historicoCard.style.maxHeight = statusAlt + 'px';
        historicoCard.style.overflowY = 'auto';
        // Mantém o scroll sempre no final para mostrar os eventos mais recentes
        if (historicoCard.scrollHeight > historicoCard.clientHeight) {
          historicoCard.scrollTop = historicoCard.scrollHeight;
        }
      }
    }

    // Run on load and resize (debounced)
    function rafEqualize(){ cancelAnimationFrame(rafEqualize._id||0); rafEqualize._id = requestAnimationFrame(equalizarAlturas); }
    window.addEventListener('resize', rafEqualize);
    // Wait a tick for layout
  setTimeout(equalizarAlturas, 50);
  setTimeout(equalizarAlturas, 250);
    // E garante scroll ao fundo mesmo em telas pequenas, se houver overflow
    const historicoCardInit = document.getElementById('historico-card');
    if (historicoCardInit) {
      setTimeout(() => {
        if (historicoCardInit.scrollHeight > historicoCardInit.clientHeight) {
          historicoCardInit.scrollTop = historicoCardInit.scrollHeight;
        }
      }, 300);
    }
    // Also after images load
    document.querySelectorAll('.mapa-img').forEach(img => {
      if (img.complete) return; img.addEventListener('load', rafEqualize);
    });
  // Inicializa controles e grade
  setupGridControls();
  updateAllGrids();

    // ====== Ações do topo: selecionar/usar/adicionar mapa ======
    function setupTopbarMapActions(){
      const formMapa = document.getElementById('form-mapa');
      const selectMapaTop = document.getElementById('mapa_existente_top');
      if (!(formMapa && selectMapaTop)) return;
      // Garante campo hidden no form real
      let hidden = formMapa.querySelector('#mapa_existente_hidden');
      if (!hidden) {
        hidden = document.createElement('input');
        hidden.type = 'hidden';
        hidden.name = 'mapa_existente';
        hidden.id = 'mapa_existente_hidden';
        formMapa.prepend(hidden);
      }

      const btnUsar = document.getElementById('btn-usar-mapa');
      function syncSelectToForm() { hidden.value = selectMapaTop.value || ''; }
      if (btnUsar) {
        // Remove listeners anteriores clonando o nó
        const clone = btnUsar.cloneNode(true);
        btnUsar.parentNode.replaceChild(clone, btnUsar);
        clone.addEventListener('click', function() {
          syncSelectToForm();
          if (!hidden.value) { alert('Selecione um mapa existente.'); return; }
          let flag = formMapa.querySelector('input[name="usar_existente"]');
          if (!flag) { flag = document.createElement('input'); flag.type = 'hidden'; flag.name = 'usar_existente'; flag.value = '1'; formMapa.appendChild(flag); }
          formMapa.submit();
        });
      }
    }
  // Bind inicial
    setupTopbarMapActions();
  ajaxifyInteractionForms();
  });

  function drag(event, id) {
    event.dataTransfer.setData("tokenId", id);
  }

  document.addEventListener("DOMContentLoaded", function() {
    document.querySelectorAll("[id^='mapa-area-']").forEach(function(mapaArea) {
      mapaArea.addEventListener("dragover", function(e) { e.preventDefault(); });
      mapaArea.addEventListener("drop", function(e) {
        e.preventDefault();
        const tokenId = e.dataTransfer.getData("tokenId");
  const canvas = mapaArea.querySelector('.mapa-canvas') || mapaArea;
  const rect = canvas.getBoundingClientRect();
        const scale = parseFloat(mapaArea.dataset.scale || '1');
        const tokenEl = document.getElementById('token-' + tokenId);
        const tokenSize = tokenEl ? parseFloat(getComputedStyle(tokenEl).width) || 40 : 40;
        const half = tokenSize / 2;
        let x = (e.clientX - rect.left - half) / scale;
        let y = (e.clientY - rect.top - half) / scale;
        // Clamp to image bounds
        const img = canvas.querySelector('.mapa-img');
        const baseW = img ? (img.naturalWidth || img.clientWidth) : 0;
        const baseH = img ? (img.naturalHeight || img.clientHeight) : 0;
        if (baseW && baseH) {
          x = Math.max(0, Math.min(baseW - tokenSize, x));
          y = Math.max(0, Math.min(baseH - tokenSize, y));
        }
  if (window.gridEnabled && window.gridEnabled()) { const snapped = window.applyGridSnap ? window.applyGridSnap(x, y) : {x, y}; x = snapped.x; y = snapped.y; }
        fetch(`/combate/atualizar-posicao-token/${tokenId}/`, {
          method: "POST",
          headers: {
            "X-CSRFToken": "{{ csrf_token }}",
            "Content-Type": "application/json"
          },
          credentials: 'same-origin',
          body: JSON.stringify({x, y})
        }).then(() => {
          const token = document.getElementById("token-" + tokenId);
          token.style.left = x + "px";
          token.style.top = y + "px";
        });
      });
      // Bind per-token Ctrl+wheel resize on initial load as well
      mapaArea.querySelectorAll('.mapa-token').forEach(token => {
        if (token.dataset.wheelResized) return;
        token.addEventListener('wheel', function(e){
          if (!e.ctrlKey) return;
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();
          const cs = getComputedStyle(token);
          const cur = parseFloat(cs.width) || 40;
          const dir = e.deltaY > 0 ? -1 : 1;
          const factor = dir > 0 ? 1.1 : 1/1.1;
          let next = +(cur * factor).toFixed(2);
          const min = 20, max = 120;
          next = Math.max(min, Math.min(max, next));
          token.style.width = next + 'px';
          token.style.height = next + 'px';
        }, { passive: false });
        token.dataset.wheelResized = '1';
      });
      // Initialize zoom controls on DOMContentLoaded as well (outside scroll area)
      const wrapper = mapaArea.closest('.mapa-wrapper') || mapaArea.parentElement;
      const zoomBar = wrapper ? wrapper.querySelector('.mapa-zoom') : null;
      const canvas = mapaArea.querySelector('.mapa-canvas');
      if (zoomBar && canvas) {
        zoomBar.querySelectorAll('button[data-zoom]').forEach(btn => {
          // Remove previous listeners by cloning (initial load safe too)
          const cloned = btn.cloneNode(true);
          btn.replaceWith(cloned);
          cloned.addEventListener('click', function(){
            const action = this.getAttribute('data-zoom');
            let scale = parseFloat(mapaArea.dataset.scale || '1');
            if (action === 'in') scale = +(scale * 1.1).toFixed(3);
            else if (action === 'out') scale = +(scale / 1.1).toFixed(3);
            else scale = 1;
            // Inline setScale with dynamic min and bounds
            const setScaleLocal = (newScale)=>{
              const img = canvas.querySelector('.mapa-img');
              const baseW = img.naturalWidth || img.clientWidth;
              const baseH = img.naturalHeight || img.clientHeight;
              const areaW = mapaArea.clientWidth || 1;
              const areaH = mapaArea.clientHeight || 1;
              const fitW = areaW / (baseW || areaW);
              const fitH = areaH / (baseH || areaH);
              const minScale = Math.min(1, Math.max(fitW, fitH));
              const maxScale = 3;
              newScale = Math.max(minScale, Math.min(maxScale, newScale));
              mapaArea.dataset.scale = String(newScale);
              canvas.style.transform = `scale(${newScale})`;
              canvas.style.minWidth = (baseW * newScale) + 'px';
              canvas.style.minHeight = (baseH * newScale) + 'px';
              if (window.updateGridForArea) { window.updateGridForArea(mapaArea); }
            };
            setScaleLocal(scale);
          });
        });
      }
      // Panning bind on initial load as well
      (function bindPanInit(){
        if (!window._mapPanKeyBound) {
          window._mapSpacePressed = false;
          window.addEventListener('keydown', (ev)=>{ if (ev.code === 'Space') { window._mapSpacePressed = true; ev.preventDefault(); } }, { capture:true });
          window.addEventListener('keyup', (ev)=>{ if (ev.code === 'Space') { window._mapSpacePressed = false; ev.preventDefault(); } }, { capture:true });
          window._mapPanKeyBound = true;
        }
        if (!mapaArea.dataset.panBound) {
          let panning = false, startX = 0, startY = 0, startL = 0, startT = 0;
          function clampScrollToBounds() {
            const canvas = mapaArea.querySelector('.mapa-canvas');
            const img = canvas ? canvas.querySelector('.mapa-img') : null;
            if (!img) return;
            const scale = parseFloat(mapaArea.dataset.scale || '1');
            const baseW = img.naturalWidth || img.clientWidth || 0;
            const baseH = img.naturalHeight || img.clientHeight || 0;
            const maxX = Math.max(0, baseW * scale - mapaArea.clientWidth);
            const maxY = Math.max(0, baseH * scale - mapaArea.clientHeight);
            if (mapaArea.scrollLeft > maxX) mapaArea.scrollLeft = maxX;
            if (mapaArea.scrollTop > maxY) mapaArea.scrollTop = maxY;
            if (mapaArea.scrollLeft < 0) mapaArea.scrollLeft = 0;
            if (mapaArea.scrollTop < 0) mapaArea.scrollTop = 0;
          }
          function onMove(ev){ if (!panning) return; const dx = ev.clientX - startX; const dy = ev.clientY - startY; mapaArea.scrollLeft = startL - dx; mapaArea.scrollTop = startT - dy; clampScrollToBounds(); }
          function endPan(){ if (!panning) return; panning = false; mapaArea.classList.remove('panning'); window.removeEventListener('mousemove', onMove, true); window.removeEventListener('mouseup', endPan, true); }
          mapaArea.addEventListener('mousedown', function(ev){ const isMiddle = ev.button === 1; const isSpaceDrag = ev.button === 0 && window._mapSpacePressed; if (!isMiddle && !isSpaceDrag) return; ev.preventDefault(); ev.stopPropagation(); panning = true; startX = ev.clientX; startY = ev.clientY; startL = mapaArea.scrollLeft; startT = mapaArea.scrollTop; mapaArea.classList.add('panning'); window.addEventListener('mousemove', onMove, true); window.addEventListener('mouseup', endPan, true); }, { capture:true });
          mapaArea.addEventListener('dragstart', function(ev){ if (window._mapSpacePressed) { ev.preventDefault(); ev.stopImmediatePropagation(); } }, true);
          mapaArea.dataset.panBound = '1';
        }
      })();

      // Wheel handler on initial bind as well
      if (!mapaArea.dataset.wheelBound) {
        mapaArea.addEventListener('wheel', function(e){
          if (!e.ctrlKey) return;
          e.preventDefault();
          let scale = parseFloat(mapaArea.dataset.scale || '1');
          const dir = e.deltaY > 0 ? -1 : 1;
          const factor = dir > 0 ? 1.1 : 1/1.1;
          scale = +(scale * factor).toFixed(3);
          const img = canvas.querySelector('.mapa-img');
          const baseW = img.naturalWidth || img.clientWidth;
          const baseH = img.naturalHeight || img.clientHeight;
          const areaW = mapaArea.clientWidth || 1;
          const areaH = mapaArea.clientHeight || 1;
          const fitW = areaW / (baseW || areaW);
          const fitH = areaH / (baseH || areaH);
          const minScale = Math.min(1, Math.max(fitW, fitH));
          const maxScale = 3;
          const oldScale = parseFloat(mapaArea.dataset.scale || '1');
          // Clamp scale to dynamic bounds
          scale = Math.max(minScale, Math.min(maxScale, scale));
          const areaRect = mapaArea.getBoundingClientRect();
          const pointerX = e.clientX - areaRect.left;
          const pointerY = e.clientY - areaRect.top;
          canvas.style.transform = `scale(${scale})`;
          canvas.style.minWidth = (baseW * scale) + 'px';
          canvas.style.minHeight = (baseH * scale) + 'px';
          mapaArea.dataset.scale = String(scale);
          const sx = mapaArea.scrollLeft;
          const sy = mapaArea.scrollTop;
          const nx = (sx + pointerX) * (scale / oldScale) - pointerX;
          const ny = (sy + pointerY) * (scale / oldScale) - pointerY;
          const maxScrollX = Math.max(0, mapaArea.scrollWidth - mapaArea.clientWidth);
          const maxScrollY = Math.max(0, mapaArea.scrollHeight - mapaArea.clientHeight);
          mapaArea.scrollLeft = Math.min(maxScrollX, Math.max(0, nx));
          mapaArea.scrollTop = Math.min(maxScrollY, Math.max(0, ny));
        }, { passive: false });
        mapaArea.dataset.wheelBound = '1';
      }
      // Clamp scroll on initial load as well
      if (!mapaArea.dataset.scrollBound) {
        mapaArea.addEventListener('scroll', function(){
          const canvas = mapaArea.querySelector('.mapa-canvas');
          const img = canvas ? canvas.querySelector('.mapa-img') : null;
          if (!img) return;
          const scale = parseFloat(mapaArea.dataset.scale || '1');
          const baseW = img.naturalWidth || img.clientWidth || 0;
          const baseH = img.naturalHeight || img.clientHeight || 0;
          const maxX = Math.max(0, baseW * scale - mapaArea.clientWidth);
          const maxY = Math.max(0, baseH * scale - mapaArea.clientHeight);
          if (mapaArea.scrollLeft > maxX) mapaArea.scrollLeft = maxX;
          if (mapaArea.scrollTop > maxY) mapaArea.scrollTop = maxY;
          if (mapaArea.scrollLeft < 0) mapaArea.scrollLeft = 0;
          if (mapaArea.scrollTop < 0) mapaArea.scrollTop = 0;
        }, { passive: true });
        mapaArea.dataset.scrollBound = '1';
      }
    });
  });
</script>

{% endblock %}

