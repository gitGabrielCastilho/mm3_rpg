{% extends 'base.html' %}
{% load static %}

{% block content %}
{{ allowed_personagem_ids|json_script:"allowedPersonagemIds" }}
<script>
  // Lista de Personagem IDs permitidos para atuar/ser alvo, derivada do AtaqueForm escopado pela sala
  try {
    window._allowedPersonagemIds = JSON.parse(document.getElementById('allowedPersonagemIds').textContent);
  } catch (_) { window._allowedPersonagemIds = []; }
  try { if (!Array.isArray(window._allowedPersonagemIds)) window._allowedPersonagemIds = []; } catch(_) {}
  window._allowedPersonagemIdsStr = (window._allowedPersonagemIds||[]).map(function(x){ return String(x); });
  // Helper para checar permissão no cliente (defensivo; servidor revalida)
  window._isPersonagemAllowed = function(pid){ try { return window._allowedPersonagemIdsStr.indexOf(String(pid)) !== -1; } catch(_) { return true; } };
  // URL resolvida pelo Django para evitar problemas de prefixo em produção
  window._poderesAjaxUrl = "{% url 'poderes_personagem_ajax' %}";
  // Token assinado para autenticar WebSocket mesmo com bloqueio de cookies
  window._wsToken = "{{ ws_token }}";
  window._wsUserId = "{{ request.user.id }}";
</script>
<div id="combate-content" class="combate-detalhes-center" data-is-gm="{% if combate.sala.game_master == user %}true{% else %}false{% endif %}">
  <!-- Topo: info de turno + ações globais -->
  <div class="turno-topbar combate-card">
    <div class="turno-topbar-row">
      <div class="turno-topbar-info">
      {% if turno_ativo %}
        <strong>Turno:</strong> <span id="turno-ativo-nome" data-personagem-id="{{ turno_ativo.personagem.id }}">{{ turno_ativo_display|default:turno_ativo.personagem.nome }}</span>
      {% else %}
        <strong>Sem turno ativo</strong>
      {% endif %}
      </div>
      <div class="turno-topbar-actions">
  {% if not turno_ativo and combate.ativo and combate.sala.game_master == user %}
        <form method="post" action="{% url 'iniciar_turno' combate.id %}" class="inline-form">
          {% csrf_token %}
          <button type="submit" class="btn btn-sm">Iniciar Turno</button>
        </form>
      {% endif %}
  {% if turno_ativo and combate.sala.game_master == user %}
        <form method="post" action="{% url 'avancar_turno' combate.id %}" class="inline-form">
          {% csrf_token %}
          <button type="submit" formnovalidate class="btn btn-sm">Avançar Turno</button>
        </form>
      {% endif %}
      {% if combate.ativo and combate.sala.game_master == user %}
        <form method="post" action="{% url 'finalizar_combate' combate.id %}" class="inline-form">
          {% csrf_token %}
          <button type="submit" class="btn btn-sm btn-danger" formnovalidate>Finalizar Combate</button>
        </form>
      {% endif %}
      </div>
    </div>
  {# Moved map selection next to the map title in the right column #}
  </div>

  <!-- Grid: Histórico (esquerda) + Mapa (centro-direita) + Ações Sidebar (direita) -->
  <div class="combate-layout-grid">
    <!-- Coluna esquerda: Histórico -->
  <div class="combate-col-left">

  <div class="mapa-header-row">
    <h3 class="combate-section-title" style="margin:0">Histórico de Ataques</h3>
    {% if combate.sala.game_master == user %}
    <div class="mapa-header-actions">
      <form method="post" action="{% url 'limpar_historico' combate.id %}" class="combate-inline-form form-limpar-historico" onsubmit="return confirm('Limpar todo o histórico de ataques? Esta ação não pode ser desfeita.');">
        {% csrf_token %}
        <button type="submit" class="btn btn-sm" formnovalidate>Limpar Histórico</button>
      </form>
    </div>
    {% endif %}
  </div>
  <div id="historico-card" class="combate-card">
  <ul class="turnos-list">
  {% for turno in turnos %}
          <li class="turno-item {% if turno.ativo %}ativo{% endif %}" data-turno-id="{{ turno.id }}" data-personagem-id="{{ turno.personagem.id }}" data-personagem-nome="{{ turno.personagem.nome }}">
            <div class="turno-header">
              <strong>Rodada {{ turno.ordem }}</strong> — <span class="turno-nome">{{ turno.personagem.nome }}</span>
              <span class="turno-data">{{ turno.criado_em|date:"d/m/Y H:i" }}</span>
              {% if turno.ativo %}<span class="status-badge atual">Ativo</span>{% endif %}
            </div>
            <div class="turno-desc">{{ turno.descricao|safe }}</div>
          </li>
        {% empty %}
          <li class="turno-item vazio"><em>Nenhum ataque registrado ainda.</em></li>
        {% endfor %}
  </ul>
  </div>
    </div>

    <script>
      // Apply server-provided display name for current turn when WS events arrive or after partial refresh
      window.applyTurnNameDisambiguation = function(){
        try {
          const topName = document.getElementById('turno-ativo-nome');
          if (!topName) return;
          // If server rendered display name already, nothing to do.
          // This function is kept for compatibility; actual updates use WS payloads.
        } catch(_) {}
      };
      // Initial run (no-op)
      try { window.applyTurnNameDisambiguation(); } catch(_) {}
    </script>

    <!-- Coluna direita: Mapa -->
    <div class="combate-col-right">
      <div class="mapa-header-row">
        <h3 class="combate-section-title" style="margin:0">Mapa do Combate</h3>
        {% if combate.sala.game_master == user %}
        <div class="mapa-header-actions">
          <label for="mapa_existente_top" class="sr-only">Selecionar mapa</label>
          <select id="mapa_existente_top" class="select-sm" title="Selecionar mapa">
            <option value="">– mapa –</option>
            {% for mapa in mapas_globais %}
              <option value="{{ mapa.id }}">{{ mapa.nome }}</option>
            {% endfor %}
          </select>
          <button type="button" id="btn-usar-mapa" class="btn btn-sm">Usar</button>
          <a href="{% url 'adicionar_mapa' combate.id %}" target="_blank" rel="noopener" id="btn-add-mapa-link" class="btn btn-sm">Novo</a>
          <!-- Grade opcional para precisão de movimento -->
          <label style="margin-left:8px; display:inline-flex; align-items:center; gap:4px;">
            <input type="checkbox" id="grid-enable"> Grade
          </label>
          <select id="grid-size" class="select-sm" title="Tamanho da grade" style="margin-left:4px;">
            <option value="20">20px</option>
            <option value="40" selected>40px</option>
            <option value="60">60px</option>
          </select>
        </div>
        {% endif %}
      </div>
      <div class="mapa-draw-toolbar">
        <div class="mdt-group">
          <button type="button" data-draw-mode="pen" class="mdt-btn active">Lápis</button>
          <button type="button" data-draw-mode="eraser" class="mdt-btn">Borracha</button>
          <button type="button" data-draw-mode="rect" class="mdt-btn">Retângulo</button>
          <button type="button" data-draw-mode="circle" class="mdt-btn">Círculo</button>
        </div>
        <div class="mdt-group mdt-colors">
          <button type="button" data-draw-color="#d33" style="background:#d33"></button>
          <button type="button" data-draw-color="#1e88e5" style="background:#1e88e5"></button>
          <button type="button" data-draw-color="#2e7d32" style="background:#2e7d32"></button>
          <button type="button" data-draw-color="#f9a825" style="background:#f9a825"></button>
          <button type="button" data-draw-color="#000000" style="background:#000000"></button>
          <button type="button" data-draw-color="#ffffff" style="background:#ffffff; border:1px solid #ccc"></button>
        </div>
        <div class="mdt-group">
          <select id="mdt-size">
            <option value="2">2px</option>
            <option value="4" selected>4px</option>
            <option value="6">6px</option>
            <option value="10">10px</option>
          </select>
          <button type="button" id="mdt-clear" class="mdt-btn">Limpar</button>
        </div>
      </div>
      {% if combate.mapas.all %}
        {% for mapa in combate.mapas.all %}
          <div class="mapa-wrapper">
            <div id="mapa-area-{{ mapa.id }}" class="mapa-area" data-scale="1">
              <div class="mapa-canvas">
  <img src="{{ mapa.imagem.url }}" alt="{{ mapa.nome }}" class="mapa-img" title="{{ mapa.imagem.url }}" data-fallback="{% static 'img/mapa_placeholder.svg' %}" onerror="this.onerror=null;this.src=this.dataset.fallback;" draggable="false" loading="lazy" decoding="async">
  {% if combate.sala.game_master == user %}
    <div class="mapa-debug-url">URL: {{ mapa.imagem.url }}</div>
  {% endif %}
            {% for posicao in posicoes %}
              {% if posicao.mapa.id == mapa.id %}
                 {% if posicao.participante.personagem.foto %}
                <img src="{{ posicao.participante.personagem.foto.url }}"
                  alt="{{ posicao.display_label|default:posicao.participante.personagem.nome }}"
                  title="{{ posicao.display_label|default:posicao.participante.personagem.nome }}"
              id="token-{{ posicao.id }}"
              class="mapa-token"
              style="left:{{ posicao.x }}px; top:{{ posicao.y }}px; width:{{ posicao.token_size|default:40 }}px; height:{{ posicao.token_size|default:40 }}px;"
              draggable="true"
              ondragstart="drag(event, {{ posicao.id }})"
              loading="lazy" decoding="async">
                {% else %}
         <div id="token-{{ posicao.id }}" class="mapa-token token-fallback"
           style="left:{{ posicao.x }}px; top:{{ posicao.y }}px; width:{{ posicao.token_size|default:40 }}px; height:{{ posicao.token_size|default:40 }}px;"
           draggable="true"
           ondragstart="drag(event, {{ posicao.id }})"
           title="{{ posicao.display_label|default:posicao.participante.personagem.nome }}">
                    {{ posicao.display_label|default:posicao.participante.personagem.nome }}
                  </div>
                {% endif %}
              {% endif %}
            {% endfor %}
              </div>
            </div>
            {% if combate.sala.game_master == user %}
              <form method="post" action="{% url 'remover_mapa' combate.id mapa.id %}" class="mapa-remover-form">
                {% csrf_token %}
                <button type="submit" class="btn btn-sm btn-danger">Remover Mapa</button>
              </form>
            {% endif %}
          </div>
        {% endfor %}
      {% endif %}



      {% if combate.sala.game_master == user %}
        {% if combate.mapas.all|length == 0 %}
        <form method="post" enctype="multipart/form-data" action="{% url 'adicionar_mapa' combate.id %}" class="combate-card mapa-upload-form" id="form-mapa">
          {% csrf_token %}
          <input type="hidden" name="mapa_existente" id="mapa_existente_hidden" value="">
          <strong>Envie um Mapa:</strong>
          {{ form.as_p }}
        </form>
        {% else %}
        <!-- Form oculto apenas para permitir a ação "Usar Selecionado" do topo -->
        <form method="post" action="{% url 'adicionar_mapa' combate.id %}" id="form-mapa" style="display:none">
          {% csrf_token %}
          <input type="hidden" name="mapa_existente" id="mapa_existente_hidden" value="">
        </form>
        {% endif %}
      {% endif %}
    </div>

  </div>

  <!-- Participantes: centralizados abaixo do histórico e mapa -->
  <div class="participantes-section-wrapper">
    <div class="participantes-section">
      <div class="mapa-header-row">
        <h3 class="combate-section-title" style="margin:0">Status dos Participantes</h3>
        {% if combate.sala.game_master == user and personagens_disponiveis %}
        <form method="post" action="{% url 'adicionar_participante' combate.id %}" class="combate-inline-form form-add-participante">
          {% csrf_token %}
          <label for="novo_participante" class="sr-only">Adicionar Personagem</label>
          <select name="personagem_id" id="novo_participante" required class="select-sm" title="Adicionar Personagem">
            {% for pers in personagens_disponiveis %}
              <option value="{{ pers.id }}">{{ pers.nome }}</option>
            {% endfor %}
          </select>
          <button type="submit" class="btn btn-sm">Adicionar Personagem</button>
        </form>
        {% endif %}
        {% if combate.sala.game_master == user and npcs_disponiveis %}
        <form method="post" action="{% url 'adicionar_npc_participante' combate.id %}" class="combate-inline-form form-add-participante">
          {% csrf_token %}
          <label for="novo_npc" class="sr-only">Adicionar NPC</label>
          <select name="npc_id" id="novo_npc" required class="select-sm" title="Adicionar NPC">
            {% for npc in npcs_disponiveis %}
              <option value="{{ npc.id }}">{{ npc.nome }}</option>
            {% endfor %}
          </select>
          <button type="submit" class="btn btn-sm">Adicionar NPC</button>
        </form>
        {% endif %}
      </div>
      <div id="status-card" class="combate-card">
        {% include 'combate/_tabela_participantes.html' %}
      </div>
    </div>
  </div>

    <!-- Sidebar direito: Ações -->
    <aside class="combate-sidebar-acoes closed" id="combate-sidebar-acoes">
      <button id="combate-sidebar-toggle" class="sidebar-toggle" onclick="toggleCombateSidebar()" title="Abrir/Fechar ações">
        <span id="combate-sidebar-toggle-icon">⮜</span>
      </button>
      <h3 class="combate-section-title">Ações de</h3>
      <div class="acao-top-row">
        <select id="personagem_acao" name="personagem_acao" form="form-ataque" class="select-md">
          {% if combate.sala.game_master == user %}
            {% for p in participantes %}
              {% if p.personagem.id in allowed_personagem_ids %}
                <option value="{{ p.id }}" data-personagem-id="{{ p.personagem.id }}">{{ p.display_nome|default:p.personagem.nome }}</option>
              {% endif %}
            {% endfor %}
          {% else %}
            {% for p in participantes %}
              {% if p.personagem.usuario == user and p.personagem.id in allowed_personagem_ids %}
                <option value="{{ p.id }}" data-personagem-id="{{ p.personagem.id }}">{{ p.display_nome|default:p.personagem.nome }}</option>
              {% endif %}
            {% endfor %}
          {% endif %}
        </select>
        <form method="post" action="{% url 'realizar_ataque' combate.id %}" id="form-d20" class="inline-form">
          {% csrf_token %}
          <input type="hidden" name="personagem_acao" id="personagem_acao_hidden_d20" value="{{ participantes.0.id }}">
          <button type="submit" name="rolar_d20" value="1" class="btn btn-sm">Rolar d20</button>
        </form>
        <form method="post" action="{% url 'encerrar_meus_efeitos' combate.id %}" class="inline-form" id="form-encerrar-meus">
          {% csrf_token %}
          <input type="hidden" name="personagem_acao" id="personagem_acao_hidden_end" value="{{ participantes.0.id }}">
          <button type="submit" class="btn btn-sm" formnovalidate title="Encerrar todos os efeitos que este personagem está mantendo">Encerrar Efeitos</button>
        </form>
      </div>

      <form method="post" action="{% url 'realizar_ataque' combate.id %}" id="form-ataque" class="combate-card ataque-card">
        {% csrf_token %}
  <input type="hidden" name="personagem_acao" id="personagem_acao_hidden" value="{{ participantes.0.id }}">
  <!-- Hidden extras para manter sincronização existente -->
  <input type="hidden" id="personagem_acao_hidden_pericia" value="{{ participantes.0.id }}">
  <input type="hidden" id="personagem_acao_hidden_caracteristica" value="{{ participantes.0.id }}">

  <label for="alvo">Alvo(s):</label>
        <small id="alvo_hint" class="form-hint" style="display:block; margin:-4px 0 6px; color:#666; font-size:12px;">
          Segure Ctrl (Windows/Linux) ou Cmd (macOS) para selecionar múltiplos; use Shift para selecionar intervalos.
        </small>
  <select id="alvo" name="alvo_id" multiple size="4" class="multiselect-alvos" aria-describedby="alvo_hint" title="Segure Ctrl (Windows/Linux) ou Cmd (macOS) para seleção múltipla; Shift para intervalos.">
          {# Ordena por iniciativa (maior primeiro) e exibe a iniciativa no texto #}
          {% for p in participantes|dictsortreversed:"iniciativa" %}
            {% if p.personagem.id in allowed_personagem_ids %}
              <option value="{{ p.id }}">[Init {{ p.iniciativa }}] {{ p.display_nome|default:p.personagem.nome }}</option>
            {% endif %}
          {% endfor %}
        </select>

        <div class="acao-row poder-row">
          <label for="poder">Poder:</label>
          <select name="poder_id" id="poder" required class="select-md" data-tipos="{}" aria-describedby="poder_hint">
            {% for poder in poderes_disponiveis %}
              <option value="{{ poder.id }}"
                      data-tipo="{{ poder.tipo }}"
                      {% if poder.de_item %}data-de-item="1"{% endif %}
                      {% if poder.item_origem %}data-item-origem="{{ poder.item_origem.nome|escape }}"{% endif %}>
                {{ poder.nome }}{% if poder.de_item and poder.item_origem %} — item: {{ poder.item_origem.nome }}{% endif %}
              </option>
            {% empty %}
              <option disabled>Nenhum poder disponível</option>
            {% endfor %}
          </select>
          <button type="submit" class="btn btn-sm" id="btn-rolar-poder">Rolar</button>
        </div>
        <small id="poder_hint" class="form-hint" style="display:block; margin:-4px 0 6px; color:#666; font-size:12px;"></small>

        <div class="acao-row">
          <label for="pericia_rolar">Perícia:</label>
          <select name="pericia" id="pericia_rolar" class="select-md">
            <option value="">-- Selecione uma perícia --</option>
            {% for pericia in pericias %}
              <option value="{{ pericia }}">{{ pericia|capfirst }}</option>
            {% endfor %}
          </select>
          <button type="submit" name="rolar_pericia" value="1" class="btn btn-sm" formnovalidate>Rolar</button>
        </div>

        <div class="acao-row">
          <label for="caracteristica_rolar">Característica:</label>
          <select name="caracteristica" id="caracteristica_rolar" class="select-md">
            <option value="">-- Selecione uma característica --</option>
            {% for c in caracteristicas %}
              <option value="{{ c }}">{{ c|capfirst }}</option>
            {% endfor %}
          </select>
          <button type="submit" name="rolar_caracteristica" value="1" class="btn btn-sm" formnovalidate>Rolar</button>
        </div>
      </form>
    </aside>

    <script>
      function toggleCombateSidebar() {
        const sidebar = document.getElementById('combate-sidebar-acoes');
        const icon = document.getElementById('combate-sidebar-toggle-icon');
        sidebar.classList.toggle('closed');
        if (sidebar.classList.contains('closed')) {
          icon.textContent = '⮞';
          sidebar.setAttribute('aria-expanded', 'false');
        } else {
          icon.textContent = '⮜';
          sidebar.setAttribute('aria-expanded', 'true');
        }
      }
      // Garante ícone correto ao carregar
      document.addEventListener('DOMContentLoaded', function() {
        const sidebar = document.getElementById('combate-sidebar-acoes');
        const icon = document.getElementById('combate-sidebar-toggle-icon');
        if (sidebar && sidebar.classList.contains('closed')) {
          icon.textContent = '⮞';
          sidebar.setAttribute('aria-expanded', 'false');
        }
      });
    </script>
  </div>

  <script>
  // Função reutilizável para sincronizar selects de personagem e poderes (chamada após partial refresh)
  function bindPersonagemAcaoSync() {
    const select = document.getElementById('personagem_acao');
    const poderSelect = document.getElementById('poder');
    if (!select) return;
    const combateId = '{{ combate.id }}';
    const SEL_PARTICIPANTE_KEY = `combate:${combateId}:participante_sel`;
    const powerKey = (personagemId) => `combate:${combateId}:power:${personagemId||''}`;
    const skillKey = (personagemId) => `combate:${combateId}:skill:${personagemId||''}`;
    const traitKey = (personagemId) => `combate:${combateId}:trait:${personagemId||''}`;
    const targetsKey = (personagemId) => `combate:${combateId}:targets:${personagemId||''}`;

    // Sequenciador de requests para evitar race conditions sobrescrevendo selects
    let _poderReqSeq = 0;
    function applyPoderTipoUI(){
      const alvoSelect = document.getElementById('alvo');
      const hint = document.getElementById('alvo_hint');
      const form = document.getElementById('form-ataque');
      const btn = document.getElementById('btn-rolar-poder');
      const poderHint = document.getElementById('poder_hint');
      if (!poderSelect || !alvoSelect) return;
      const opt = poderSelect.options[poderSelect.selectedIndex];
      const tipo = opt ? (opt.dataset.tipo || '') : '';
      const origemItem = opt ? (opt.dataset.itemOrigem || '') : '';
      if (tipo === 'descritivo') {
        alvoSelect.disabled = true;
        alvoSelect.required = false;
        alvoSelect.setAttribute('aria-required', 'false');
        if (form) form.setAttribute('novalidate', 'novalidate');
        if (btn) btn.setAttribute('formnovalidate', 'formnovalidate');
        if (hint) hint.textContent = 'Poder descritivo: não requer alvos.';
        if (poderHint) {
          const base = 'Rola d20 + nível do poder.';
          poderHint.textContent = origemItem ? (base + ' Origem: item ' + origemItem + '.') : base;
        }
      } else {
        alvoSelect.disabled = false;
        alvoSelect.required = true;
        alvoSelect.setAttribute('aria-required', 'true');
        if (form) form.removeAttribute('novalidate');
        if (btn) btn.removeAttribute('formnovalidate');
        if (hint) hint.textContent = 'Segure Ctrl (Windows/Linux) ou Cmd (macOS) para selecionar múltiplos; use Shift para selecionar intervalos.';
        if (poderHint) {
          poderHint.textContent = origemItem ? ('Origem: item ' + origemItem + '.') : '';
        }
      }
    }
    function bindPoderStorageListener(){
      if (!poderSelect || poderSelect.dataset.boundStorage) return;
      poderSelect.addEventListener('change', function(){
        const selNow = document.getElementById('personagem_acao');
        const opt = selNow ? selNow.options[selNow.selectedIndex] : null;
        const personagemId = opt ? opt.getAttribute('data-personagem-id') : '';
        if (personagemId) {
          try { localStorage.setItem(powerKey(personagemId), String(poderSelect.value||'')); } catch(_) {}
        }
        // Atualiza UI de alvos conforme tipo do poder
        applyPoderTipoUI();
      });
      poderSelect.dataset.boundStorage = '1';
    }

    function restoreSkillAndTrait(personagemId){
      try {
        const perSel = document.getElementById('pericia_rolar');
        const carSel = document.getElementById('caracteristica_rolar');
        const svPer = localStorage.getItem(skillKey(personagemId)) || '';
        const svCar = localStorage.getItem(traitKey(personagemId)) || '';
        if (perSel && svPer) perSel.value = svPer;
        if (carSel && svCar) carSel.value = svCar;
      } catch(_) {}
    }
    function persistSkillAndTraitBind(){
      const perSel = document.getElementById('pericia_rolar');
      const carSel = document.getElementById('caracteristica_rolar');
      if (perSel && !perSel.dataset.persist){
        perSel.addEventListener('change', function(){
          const selNow = document.getElementById('personagem_acao');
          const opt = selNow ? selNow.options[selNow.selectedIndex] : null;
          const personagemId = opt ? opt.getAttribute('data-personagem-id') : '';
          if (personagemId) try { localStorage.setItem(skillKey(personagemId), String(perSel.value||'')); } catch(_) {}
        });
        perSel.dataset.persist = '1';
      }
      if (carSel && !carSel.dataset.persist){
        carSel.addEventListener('change', function(){
          const selNow = document.getElementById('personagem_acao');
          const opt = selNow ? selNow.options[selNow.selectedIndex] : null;
          const personagemId = opt ? opt.getAttribute('data-personagem-id') : '';
          if (personagemId) try { localStorage.setItem(traitKey(personagemId), String(carSel.value||'')); } catch(_) {}
        });
        carSel.dataset.persist = '1';
      }
    }
    function restoreTargets(personagemId){
      try {
        const alvoSel = document.getElementById('alvo');
        if (!alvoSel) return;
        const saved = localStorage.getItem(targetsKey(personagemId));
        if (!saved) return;
        const ids = JSON.parse(saved);
        if (Array.isArray(ids)) {
          Array.from(alvoSel.options).forEach(o => { o.selected = ids.includes(String(o.value)); });
        }
      } catch(_) {}
    }
    function persistTargetsBind(){
      const alvoSel = document.getElementById('alvo');
      if (alvoSel && !alvoSel.dataset.persist){
        alvoSel.addEventListener('change', function(){
          const opt = select ? select.options[select.selectedIndex] : null;
          const personagemId = opt ? opt.getAttribute('data-personagem-id') : '';
          if (personagemId) {
            try {
              const ids = Array.from(alvoSel.selectedOptions || []).map(o => String(o.value));
              localStorage.setItem(targetsKey(personagemId), JSON.stringify(ids));
            } catch(_) {}
          }
        });
        alvoSel.dataset.persist = '1';
      }
    }

    function syncPersonagemAcao() {
  const selNow = document.getElementById('personagem_acao');
  const val = selNow ? selNow.value : '';
  const selectedOpt = selNow ? selNow.options[selNow.selectedIndex] : null;
      const personagemId = selectedOpt ? selectedOpt.getAttribute('data-personagem-id') : '';
      const h1 = document.getElementById('personagem_acao_hidden');
      const h2 = document.getElementById('personagem_acao_hidden_pericia');
      const h3 = document.getElementById('personagem_acao_hidden_caracteristica');
      const h4 = document.getElementById('personagem_acao_hidden_d20');
      const h5 = document.getElementById('personagem_acao_hidden_end');
      if (h1) h1.value = val; if (h2) h2.value = val; if (h3) h3.value = val; if (h4) h4.value = val; if (h5) h5.value = val;
      // Restaura perícia/traço/alvos persistidos
      restoreSkillAndTrait(personagemId);
      restoreTargets(personagemId);
      if (poderSelect) {
        // Se não houver um personagem válido selecionado, limpa o select de poderes e sai
        if (!personagemId) {
          try {
            poderSelect.innerHTML = '';
            const opt = document.createElement('option');
            opt.disabled = true;
            opt.textContent = 'Selecione um participante';
            poderSelect.appendChild(opt);
          } catch(_) {}
          return;
        }
        // Preferência salva por personagem (se existir)
        let savedValue = '';
        try { savedValue = localStorage.getItem(powerKey(personagemId)) || ''; } catch(_) {}
        const prevValue = poderSelect.value; // fallback: preserva seleção atual
        const mySeq = ++_poderReqSeq;
        const baseUrl = (window._poderesAjaxUrl || '/combate/poderes-personagem-ajax/');
        const url = baseUrl + (baseUrl.indexOf('?') === -1 ? '?' : '&') + 'personagem_id=' + encodeURIComponent(personagemId);
        fetch(url)
          .then(resp => resp.json())
          .then(data => {
            // Ignora respostas atrasadas
            if (mySeq !== _poderReqSeq) return;
      poderSelect.innerHTML = '';
            let restored = false;
            if (data.poderes && data.poderes.length > 0) {
              data.poderes.forEach(function(p) {
                const opt = document.createElement('option');
                opt.value = p.id; // representante
                // Exibe origem do item quando aplicável
                const deItem = (p.de_item === true || p.de_item === '1');
                const origem = (p.item_origem_nome || p.item_origem || '');
                opt.textContent = deItem && origem ? (p.nome + ' — item: ' + origem) : p.nome;
                if (p.tipo) opt.dataset.tipo = p.tipo;
                if (p.duracao) opt.dataset.duracao = p.duracao;
                if (p.equivalentes) opt.dataset.equivalentes = p.equivalentes.join(',');
                if (deItem) opt.dataset.deItem = '1';
                if (origem) opt.dataset.itemOrigem = origem;
                // Prefer savedValue; depois tenta prevValue (qualquer equivalente também vale)
                const eqSet = new Set([String(p.id)].concat((p.equivalentes||[]).map(String)));
                if (!restored && savedValue && eqSet.has(String(savedValue))) { opt.selected = true; restored = true; }
                else if (!restored && eqSet.has(String(prevValue))) { opt.selected = true; restored = true; }
                poderSelect.appendChild(opt);
              });
            } else {
              const opt = document.createElement('option');
              opt.disabled = true;
              opt.textContent = 'Nenhum poder disponível';
              poderSelect.appendChild(opt);
            }
            // Se não restaurou, mantém o primeiro como seleção padrão
            if (!restored && poderSelect.options.length) poderSelect.selectedIndex = 0;
            poderSelect.dataset.forPersonagemId = String(personagemId || '');
            // Garante que o listener de storage esteja ativo
            bindPoderStorageListener();
            // Ajusta UI de alvos conforme tipo do poder selecionado
            applyPoderTipoUI();
            // Garante que o clique no botão de poder não dispare validação quando for descritivo
            const btn = document.getElementById('btn-rolar-poder');
            if (btn && !btn.dataset.boundDescritivo) {
              btn.addEventListener('click', function(){
                try {
                  const opt = poderSelect.options[poderSelect.selectedIndex];
                  const tipo = opt ? (opt.dataset.tipo || '') : '';
                  const alvoSel = document.getElementById('alvo');
                  if (tipo === 'descritivo') {
                    this.setAttribute('formnovalidate', 'formnovalidate');
                    if (alvoSel) { alvoSel.disabled = true; alvoSel.required = false; }
                  } else {
                    this.removeAttribute('formnovalidate');
                    if (alvoSel) { alvoSel.disabled = false; alvoSel.required = true; }
                  }
                } catch(_) {}
              });
              btn.dataset.boundDescritivo = '1';
            }
            // Após popular poderes, também reanexar binds de persistência e restaurar escolhas
            persistSkillAndTraitBind();
            persistTargetsBind();
          })
          .catch(() => {/* silencia para evitar reset visual em falhas */});
      }
    }
    // Expõe a função para listeners delegados e rebinds externos
    try { window._syncPersonagemAcao = syncPersonagemAcao; } catch(_) {}
    // Evita listeners duplicados trocando o nó
  const newSelect = select.cloneNode(true);
    // Restaura escolha persistida do participante (se existir)
    try {
      const savedPart = localStorage.getItem(SEL_PARTICIPANTE_KEY) || '';
      if (savedPart) {
        for (let i = 0; i < newSelect.options.length; i++) {
          if (String(newSelect.options[i].value) === String(savedPart)) { newSelect.selectedIndex = i; break; }
        }
      }
    } catch(_) {}
    select.replaceWith(newSelect);
    newSelect.addEventListener('change', function(){
      try { localStorage.setItem(SEL_PARTICIPANTE_KEY, String(newSelect.value||'')); } catch(_) {}
      syncPersonagemAcao();
    });
    // Garante um valor selecionado válido
    if (newSelect.options.length && newSelect.selectedIndex < 0) newSelect.selectedIndex = 0;
  // Força sincronização inicial com a escolha restaurada
    try { if (newSelect.value) localStorage.setItem(SEL_PARTICIPANTE_KEY, String(newSelect.value)); } catch(_) {}
  // Bind inicial: sempre sincroniza para refletir o selecionado
  syncPersonagemAcao();
    // Assegura listener para salvar seleção
    bindPoderStorageListener();
  // Ajuste inicial do tipo do poder (caso já haja conteudo)
  try { applyPoderTipoUI(); } catch(_) {}
  // Binds de persistência para perícia/traço/alvos
  persistSkillAndTraitBind();
  persistTargetsBind();
    // Bind inicial do botão rolar poder (descritivo no primeiro carregamento)
    const _btnInit = document.getElementById('btn-rolar-poder');
    if (_btnInit && !_btnInit.dataset.boundDescritivo) {
      _btnInit.addEventListener('click', function(){
        try {
          const opt = poderSelect && poderSelect.options ? poderSelect.options[poderSelect.selectedIndex] : null;
          const tipo = opt ? (opt.dataset.tipo || '') : '';
          const alvoSel = document.getElementById('alvo');
          if (tipo === 'descritivo') {
            this.setAttribute('formnovalidate', 'formnovalidate');
            if (alvoSel) { alvoSel.disabled = true; alvoSel.required = false; }
          } else {
            this.removeAttribute('formnovalidate');
            if (alvoSel) { alvoSel.disabled = false; alvoSel.required = true; }
          }
        } catch(_) {}
      });
      _btnInit.dataset.boundDescritivo = '1';
    }
  }
  document.addEventListener('DOMContentLoaded', bindPersonagemAcaoSync);
  // Fallback: listener delegado para garantir atualização mesmo se o bind específico falhar
  (function(){
    if (document && !document._acoesDeChangeDelegated) {
      document.addEventListener('change', function(e){
        try {
          const t = e.target || e.srcElement;
          if (t && t.id === 'personagem_acao') {
            if (typeof window._syncPersonagemAcao === 'function') window._syncPersonagemAcao();
          }
        } catch(_) {}
      }, true);
      document._acoesDeChangeDelegated = true;
    }
  
    // Expõe bindPersonagemAcaoSync ao window para callbacks externos
    window.bindPersonagemAcaoSync = bindPersonagemAcaoSync;
  })();
  </script>

  <style>
    .mapa-draw-toolbar{
      display:flex; flex-wrap:wrap; gap:8px; align-items:center; margin:8px 0 8px;
      padding:8px 12px; 
      background: #262626;
      border:1px solid #3a3a3a; 
      border-radius:12px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    }
    .mdt-group{display:flex; gap:6px; align-items:center;}
    .mdt-btn{
      padding:6px 12px; 
      border:1px solid #3a3a3a; 
      border-radius:8px; 
      background:#1a1a1a; 
      color:#f5f5f5;
      cursor:pointer; 
      font-size:13px;
      font-weight:600;
      transition: all 0.2s cubic-bezier(.4,0,.2,1);
      box-shadow: 0 1px 4px rgba(0,0,0,0.15);
    }
    .mdt-btn:hover{
      background:#2a2a2a;
      border-color:#4a4a4a;
    }
    .mdt-btn.active{
      background:#c53131; 
      border-color:#c53131; 
      color:#fff;
      box-shadow: 0 2px 8px rgba(197,49,49,0.3);
    }
    .mdt-colors button{
      width:24px; height:24px; border-radius:50%; border:2px solid #3a3a3a; cursor:pointer; padding:0;
      transition: transform 0.2s, box-shadow 0.2s;
    }
    .mdt-colors button:hover{
      transform: scale(1.1);
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
    }
    .mdt-colors button.active{
      border-color:#e6c200;
      box-shadow: 0 0 0 2px #e6c200;
    }
    #mdt-size, #mdt-clear{
      padding:6px 10px;
      border:1px solid #3a3a3a;
      border-radius:8px;
      background:#1a1a1a;
      color:#f5f5f5;
      font-size:13px;
      cursor:pointer;
      transition: all 0.2s;
    }
    #mdt-size:hover, #mdt-clear:hover{
      background:#2a2a2a;
      border-color:#4a4a4a;
    }
    #mdt-clear{
      background:#a32a2a;
      border-color:#a32a2a;
      color:#fff;
      font-weight:600;
    }
    #mdt-clear:hover{
      background:#e6c200;
      border-color:#e6c200;
      color:#23272a;
    }
    canvas.mapa-draw-layer,
    canvas.mapa-draw-preview{
      position:absolute; left:0; top:0; pointer-events:auto; z-index:50; touch-action:none;
    }
    .mapa-draw-layer{ cursor: crosshair; }
    .mapa-canvas, .mapa-img, canvas.mapa-draw-layer, canvas.mapa-draw-preview { user-select:none; }
    .mapa-canvas { position: relative; }
    .mapa-img { display:block; max-width:100%; height:auto; object-fit:contain; }
    .mapa-debug-url { font-size:12px; color:#888; margin-top:4px; word-break:break-all; }
    
    /* Estilos para logs de ataque formatados */
    .ataque-log {
      background: #1a1a1a;
      border-left: 4px solid var(--gold);
      padding: 12px 14px;
      margin: 8px 0;
      border-radius: 4px;
      font-size: 0.95em;
      line-height: 1.5;
    }
    
    .ataque-header {
      font-size: 1.05em;
      margin-bottom: 8px;
      color: #e8e8e8;
    }
    
    .badge-modo {
      display: inline-block;
      background: #2a2a2a;
      color: var(--gold);
      padding: 2px 8px;
      border-radius: 3px;
      font-size: 0.85em;
      font-weight: 600;
      margin-right: 6px;
      border: 1px solid #444;
    }
    
    .poder-nome {
      color: var(--gold);
      font-style: normal;
      font-weight: 600;
    }
    
    .ataque-alvos {
      color: #aaa;
      font-size: 0.95em;
      margin-bottom: 10px;
      padding-left: 4px;
    }
    
    .ataque-rolls {
      display: grid;
      grid-template-columns: auto 1fr;
      gap: 6px 12px;
      margin: 10px 0;
      padding: 8px 10px;
      background: #141414;
      border-radius: 3px;
      font-size: 0.93em;
    }
    
    .ataque-rolls dt {
      font-weight: 600;
      color: var(--gold);
    }
    
    .ataque-rolls dd {
      margin: 0;
      color: #d0d0d0;
    }
    
    .roll-resultado {
      font-weight: 600;
      text-transform: uppercase;
      font-size: 0.9em;
    }
    
    .ataque-efeitos {
      margin-top: 10px;
      padding: 8px 10px;
      background: #0f0f0f;
      border-radius: 3px;
    }
    
    .ataque-efeitos strong {
      color: var(--gold);
      font-size: 0.95em;
    }
    
    .efeitos-list {
      list-style: none;
      padding: 0;
      margin: 6px 0 0 0;
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }
    
    .efeitos-list li {
      display: inline-block;
      padding: 3px 8px;
      border-radius: 3px;
      font-size: 0.9em;
      background: #1e1e1e;
      border-left: 3px solid #666;
      color: #e0e0e0;
    }
    
    .efeito-immune {
      border-left-color: #748ffc !important;
      background: #1a1d2e !important;
      font-weight: 600;
    }
    
    .efeito-resist {
      border-left-color: #ffd43b !important;
      background: #2a2415 !important;
    }
    
    .efeito-incap {
      border-left-color: #ff8787 !important;
      background: #2e1a1a !important;
      font-weight: 600;
    }
    
    .efeito-neutral {
      border-left-color: #868e96 !important;
      opacity: 0.7;
    }
    
    .ataque-duracao {
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px solid #2a2a2a;
      color: #999;
      font-size: 0.88em;
    }
  </style>

  
</div>

<script>
  document.addEventListener('DOMContentLoaded', function() {
    const combateId = '{{ combate.id }}';
    // Identificador de cliente para ignorar eco dos próprios desenhos
    window.DRAW_CLIENT_ID = window.DRAW_CLIENT_ID || ('draw-' + Math.random().toString(36).slice(2, 10));
    // ====== Histórico: melhor legibilidade ======
    function removeAccents(str){ try { return (str||'').normalize('NFD').replace(/[\u0300-\u036f]/g,''); } catch(_) { return str||''; } }
    function enhanceHistorico(container){
      const scope = container || document;
      const cards = scope.querySelectorAll('.turno-desc');
      cards.forEach(desc => {
        if (!desc) return;
        // Guard: if already enhanced and content signature didn't change, skip
        const raw = (desc.dataset.rawHtml && desc.dataset.rawHtml !== '') ? desc.dataset.rawHtml : desc.innerHTML;
        const currentSig = String(raw.length) + ':' + (raw.match(/<br\s*\/?>(?=\s*\S)/gi)||[]).length;
        if (desc.dataset.enhancedSig === currentSig) return;
        // Capture raw HTML once (first run) to avoid compounding wraps
        let html = desc.dataset.rawHtml || desc.innerHTML;
        desc.dataset.rawHtml = html;
        // Split by <br> or newlines into actions
        const parts = html
          .replace(/\r/g,'')
          .split(/<br\s*\/?>(?:\s*)|\n/g)
          .map(s => s.trim())
          .filter(Boolean);
        // Build new DOM
        const frag = document.createDocumentFragment();
        parts.forEach((line, idx) => {
          const div = document.createElement('div');
          div.className = 'hist-acao';
          // Leading bullet removal
          line = line.replace(/^•\s*/, '').trim();
          // Wrap leading [TAG] into badge
          const tagMatch = line.match(/^\[(.+?)\]\s*/);
          if (tagMatch) {
            const tagText = tagMatch[1];
            const slug = removeAccents(tagText).toLowerCase().replace(/[^a-z0-9]+/g,'-');
            const tagSpan = `<span class="hist-tag tag-${slug}">${tagText}</span>`;
            line = tagSpan + ' ' + line.slice(tagMatch[0].length);
          }
          // Highlight common keywords and numbers
          line = line
            .replace(/\bCD\s*(\d+)\b/g, '<span class="hist-key">CD</span> <span class="hist-num">$1</span>')
            .replace(/\bDano\b/g, '<span class="hist-key dano">Dano</span>')
            .replace(/\bAfli[cç][aã]o\b/gi, '<span class="hist-key aflicao">Aflição</span>')
            .replace(/\bteste\b/gi, '<span class="hist-key teste">teste</span>');
          div.innerHTML = line;
          frag.appendChild(div);
        });
        desc.innerHTML = '';
        desc.appendChild(frag);
        desc.dataset.enhancedSig = currentSig;
      });
      // Collapsible rounds: header toggle with persisted state
      scope.querySelectorAll('.turno-item').forEach(li => {
        const hid = li.getAttribute('data-turno-id') || '';
        const key = `combate:${combateId}:turno:${hid}:col`;
        const header = li.querySelector('.turno-header');
        if (header && !header.dataset.collapseBound) {
          header.style.cursor = 'pointer';
          header.setAttribute('role','button');
          header.addEventListener('click', () => {
            li.classList.toggle('collapsed');
            try { localStorage.setItem(key, li.classList.contains('collapsed') ? '1' : '0'); } catch(_) {}
          });
          header.dataset.collapseBound = '1';
        }
        // Restore saved collapsed state
        try {
          const saved = localStorage.getItem(key);
          if (saved === '1') li.classList.add('collapsed');
        } catch(_) {}
      });
    }
    (function(){
      var rootEl = document.getElementById('combate-content');
      window._IS_GM = !!(rootEl && rootEl.dataset && rootEl.dataset.isGm === 'true');
    })();
    const IS_GM = window._IS_GM;
    const wsScheme = window.location.protocol === 'https:' ? 'wss' : 'ws';
    const wsToken = window._wsToken ? `?ws_token=${encodeURIComponent(window._wsToken)}` : '';
    const wsPath = `${wsScheme}://${window.location.host}/ws/combate/${combateId}/${wsToken}`;
    console.log('Tentando conectar WebSocket:', wsPath);
    console.log('Token presente:', !!window._wsToken);
    if (window._wsToken) {
      console.log('Token primeiros 50 chars:', window._wsToken.substring(0, 50));
    }
    let combateSocket = new WebSocket(wsPath);
  let lastEventAt = Date.now();

  // Fallback: polling quando WS não estiver disponível ou WS ficar ocioso
    let _combatePollTimer = null;
    function startCombatePolling(){
      if (_combatePollTimer) return;
      let tick = 0;
      _combatePollTimer = setInterval(() => {
        // Evita refreshs visuais enquanto o usuário interage com selects/inputs
        try {
          const ae = document.activeElement;
          if (ae && (ae.tagName === 'SELECT' || ae.tagName === 'INPUT' || ae.tagName === 'TEXTAREA')) return;
        } catch(_) {}
        tick = (tick + 1) % 12; // 12 * 5s = 60s
        const wsDown = !window._combateWsActive; // se WS caiu precisamos atualizar também o form de ataque (alvos)
        // Se usuário está lendo o histórico (não perto do fim), evite atualizar o card para não perder a posição
        const hc = document.getElementById('historico-card');
        const userReading = (()=>{ try { return hc && (hc.scrollHeight - hc.scrollTop - hc.clientHeight) >= 24; } catch(_) { return false; } })();
        if (tick === 0) {
          const sels = ['.turno-topbar', '#status-card'];
          if (!userReading) sels.splice(1, 0, '#historico-card');
          if (wsDown) tryUpdateTargetsLight();
          refreshSelectors(sels).catch(()=>{});
        } else if (tick === 6) {
          const sels = ['#status-card'];
          if (wsDown) tryUpdateTargetsLight();
          refreshSelectors(sels).catch(()=>{});
        } else {
          const sels = ['.turno-topbar', '#status-card'];
          if (!userReading) sels.splice(1, 0, '#historico-card');
          if (wsDown) tryUpdateTargetsLight();
          refreshSelectors(sels).catch(()=>{});
        }
      }, 5000);
    }
    function stopCombatePolling(){ if (_combatePollTimer) { clearInterval(_combatePollTimer); _combatePollTimer = null; } }
    // Heartbeat: se não chegar nenhuma mensagem por um tempo, ativa polling auxiliar
    let _hbTimer = null;
    function startHeartbeat(){
      if (_hbTimer) return;
      _hbTimer = setInterval(() => {
        const idleMs = Date.now() - lastEventAt;
        if (idleMs > 12000) { // >12s sem eventos: garante refresh e polling ligado
          startCombatePolling();
          // Se usuário está interagindo com selects/inputs, não force refresh agora
          try {
            const ae = document.activeElement;
            if (ae && (ae.tagName === 'SELECT' || ae.tagName === 'INPUT' || ae.tagName === 'TEXTAREA')) return;
          } catch(_) {}
          const hc = document.getElementById('historico-card');
          const userReading = (()=>{ try { return hc && (hc.scrollHeight - hc.scrollTop - hc.clientHeight) >= 24; } catch(_) { return false; } })();
          const wsDown = !window._combateWsActive;
          const sels = ['.turno-topbar', '#status-card'];
          if (!userReading) sels.splice(1, 0, '#historico-card');
          if (wsDown) tryUpdateTargetsLight();
          refreshSelectors(sels).catch(()=>{});
        }
      }, 8000);
    }
    function stopHeartbeat(){ if (_hbTimer) { clearInterval(_hbTimer); _hbTimer = null; } }

    // Persistência de preferências da grade por combate
    const GRID_ENABLED_KEY = `combate:${combateId}:gridEnabled`;
    const GRID_SIZE_KEY = `combate:${combateId}:gridSize`;
    function persistGridState() {
      const cb = document.getElementById('grid-enable');
      const sel = document.getElementById('grid-size');
      if (cb) localStorage.setItem(GRID_ENABLED_KEY, cb.checked ? '1' : '0');
      if (sel) localStorage.setItem(GRID_SIZE_KEY, sel.value || '40');
    }
    function restoreGridStateIfNeeded() {
      const cb = document.getElementById('grid-enable');
      const sel = document.getElementById('grid-size');
      const savedEnabled = localStorage.getItem(GRID_ENABLED_KEY);
      const savedSize = localStorage.getItem(GRID_SIZE_KEY);
      if (cb && !cb.dataset.restored && savedEnabled !== null) {
        cb.checked = savedEnabled === '1';
        cb.dataset.restored = '1';
      }
      if (sel && !sel.dataset.restored && savedSize) {
        sel.value = savedSize;
        sel.dataset.restored = '1';
      }
    }


    // ====== Grade (grid) opcional para melhorar precisão com zoom ======
  function gridEnabled(){
      const cb = document.getElementById('grid-enable');
      return !!(cb && cb.checked);
    }
    function getGridSize(){
      const sel = document.getElementById('grid-size');
      const v = sel && parseInt(sel.value, 10);
      return Number.isFinite(v) && v > 4 ? v : 40;
    }
    function applyGridSnap(x, y){
      const cell = getGridSize();
      x = Math.round(x / cell) * cell;
      y = Math.round(y / cell) * cell;
      return {x, y};
    }
    function updateGridForArea(mapaArea){
      const canvas = mapaArea && mapaArea.querySelector('.mapa-canvas');
      if (!canvas) return;
      if (!gridEnabled()){
        canvas.style.backgroundImage = '';
        canvas.style.backgroundSize = '';
        canvas.style.backgroundPosition = '';
        return;
      }
      const scale = parseFloat(mapaArea.dataset.scale || '1');
      const cell = getGridSize();
      const cellPx = Math.max(4, Math.round(cell * scale));
      // Linhas de 1px cinza claro; duas grades (x e y)
      const line = 'rgba(0,0,0,0.12)';
      canvas.style.backgroundImage = `
        repeating-linear-gradient(to right, ${line} 0, ${line} 1px, transparent 1px, transparent ${cellPx}px),
        repeating-linear-gradient(to bottom, ${line} 0, ${line} 1px, transparent 1px, transparent ${cellPx}px)
      `;
      canvas.style.backgroundSize = `${cellPx}px ${cellPx}px`;
      canvas.style.backgroundPosition = '0 0';
    }
    function updateAllGrids(){
      document.querySelectorAll("[id^='mapa-area-']").forEach(updateGridForArea);
    }
    // Garante que imagens pequenas sejam ampliadas para cobrir a área visível
    function ensureMinScaleForArea(mapaArea){
      if (!mapaArea) return;
      const canvas = mapaArea.querySelector('.mapa-canvas');
      const img = canvas ? canvas.querySelector('.mapa-img') : null;
      if (!canvas || !img) return;
      const areaW = mapaArea.clientWidth || 1;
      const areaH = mapaArea.clientHeight || 1;
      const baseW = img.naturalWidth || img.clientWidth || 1;
      const baseH = img.naturalHeight || img.clientHeight || 1;
      const fitW = areaW / (baseW || areaW);
      const fitH = areaH / (baseH || areaH);
      const minScale = Math.max(fitW, fitH); // permite upscaling
      let cur = parseFloat(mapaArea.dataset.scale || '1') || 1;
      if (cur < minScale || !isFinite(cur)) {
        cur = minScale;
        mapaArea.dataset.scale = String(cur);
        canvas.style.transform = `scale(${cur})`;
        canvas.style.minWidth = (baseW * cur) + 'px';
        canvas.style.minHeight = (baseH * cur) + 'px';
        updateGridForArea(mapaArea);
        if (window.updateDrawLayerSizes) window.updateDrawLayerSizes();
      }
    }
    function ensureAllAreasMinScale(){
      document.querySelectorAll("[id^='mapa-area-']").forEach(ensureMinScaleForArea);
    }

    // ====== Camada de desenho livre (persistido no servidor) ======
    (function(){
      const DRAW_COLORS = ['#d33','#1e88e5','#2e7d32','#f9a825','#000000','#ffffff'];
      const DRAW_MODE_KEY = `combate:${combateId}:drawMode`;
      const DRAW_COLOR_KEY = `combate:${combateId}:drawColor`;
      
      // Restore saved mode/color or default
      let currentMode = 'pen';
      let currentColor = DRAW_COLORS[0];
      try {
        const savedMode = localStorage.getItem(DRAW_MODE_KEY);
        if (savedMode && ['pen','eraser','rect','circle'].includes(savedMode)) currentMode = savedMode;
        const savedColor = localStorage.getItem(DRAW_COLOR_KEY);
        if (savedColor && DRAW_COLORS.includes(savedColor)) currentColor = savedColor;
      } catch(_) {}
      
      let currentSize = 4;

      function salvarCanvasCompleto(mapaArea){
        try {
          const mapaId = (mapaArea && mapaArea.id || '').replace('mapa-area-','');
          if (!mapaId) return;
          const canvas = mapaArea.querySelector('.mapa-draw-layer');
          if (!canvas) return;
          canvas.toBlob(blob => {
            if (!blob) return;
            const formData = new FormData();
            formData.append('imagem', blob, 'desenho.png');
            fetch(`/combate/mapa/${mapaId}/salvar-desenho/`, {
              method: 'POST',
              headers: {
                'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value,
              },
              credentials: 'same-origin',
              body: formData,
            }).catch(err => console.warn('Falha ao salvar desenho:', err));
          }, 'image/png');
        } catch(_) {}
      }

      function setActiveMode(btn){
        document.querySelectorAll('.mapa-draw-toolbar .mdt-btn[data-draw-mode]').forEach(b=>{
          b.classList.remove('active');
          b.setAttribute('aria-pressed','false');
        });
        if (btn) {
          btn.classList.add('active');
          btn.setAttribute('aria-pressed','true');
        }
      }

      function resizeCanvasPair(mapaArea, canvas, preview){
        const img = mapaArea.querySelector('.mapa-img');
        const holder = mapaArea.querySelector('.mapa-canvas') || mapaArea;
        const rect = holder.getBoundingClientRect();
        const scale = parseFloat(mapaArea.dataset.scale || '1') || 1;
        const baseW = (img && img.naturalWidth) ? img.naturalWidth : ((rect.width || mapaArea.clientWidth) / scale);
        const baseH = (img && img.naturalHeight) ? img.naturalHeight : ((rect.height || mapaArea.clientHeight) / scale);
        const targetW = baseW;
        const targetH = baseH;

        // If size is unchanged, avoid resetting the canvas (which would erase drawings)
        const needsResize = !canvas || canvas.width !== targetW || canvas.height !== targetH;
        // Preserve current drawings before resizing
        let savedImage = null;
        if (canvas && needsResize) {
          const temp = document.createElement('canvas');
          temp.width = canvas.width;
          temp.height = canvas.height;
          const tctx = temp.getContext('2d');
          tctx.drawImage(canvas, 0, 0);
          savedImage = temp;
        }

        [canvas, preview].forEach(cv => {
          if (!cv) return;
          cv.width = targetW;
          cv.height = targetH;
          cv.style.width = targetW + 'px'; // parent transform handles scale
          cv.style.height = targetH + 'px';
          cv.style.transformOrigin = 'top left';
          cv.style.transform = 'none';
        });

        // Restore drawings after resize
        if (savedImage && canvas) {
          const cctx = canvas.getContext('2d');
          cctx.drawImage(savedImage, 0, 0, savedImage.width, savedImage.height);
        }
      }

      // Expose so zoom/pan handlers outside this IIFE can reuse it safely
      window.resizeCanvasPair = resizeCanvasPair;

      function ensureDrawLayer(mapaArea){
        if (!mapaArea) return;
       
         // Skip if already initialized
         if (mapaArea.dataset.drawLayerInitialized === '1') {
           return;
         }
       
        let canvas = mapaArea.querySelector('.mapa-draw-layer');
        let preview = mapaArea.querySelector('.mapa-draw-preview');
        if (!canvas) {
          canvas = document.createElement('canvas');
          canvas.className = 'mapa-draw-layer';
          canvas.style.pointerEvents = 'none';
          preview = document.createElement('canvas');
          preview.className = 'mapa-draw-preview';
          preview.style.pointerEvents = 'none';
          // Append to mapaArea directly, not to .mapa-canvas
          mapaArea.appendChild(canvas);
          mapaArea.appendChild(preview);
          // Immediately set dimensions before first draw
          resizeCanvasPair(mapaArea, canvas, preview);
        }
        // Keep canvases transparent to pointer hit-testing; we listen on mapaArea
        canvas.style.pointerEvents = 'none';
        preview.style.pointerEvents = 'none';
        // Bind drawing events (will skip if already bound)
        bindDrawing(mapaArea, canvas, preview);
         // Mark as initialized so we don't reinitialize
         mapaArea.dataset.drawLayerInitialized = '1';
      }

      function toCoord(e, mapaArea){
        const canvas = mapaArea.querySelector('.mapa-draw-layer');
        const rect = canvas ? canvas.getBoundingClientRect() : mapaArea.getBoundingClientRect();
        const scale = parseFloat(mapaArea.dataset.scale || '1') || 1;
        return {
          x: (e.clientX - rect.left + mapaArea.scrollLeft) / scale,
          y: (e.clientY - rect.top + mapaArea.scrollTop) / scale,
          canvas
        };
      }

      function bindDrawing(mapaArea, canvas, preview){
        if (!canvas || !preview) {
          return;
        }
        
        // Skip if already bound to this mapaArea
        if (mapaArea.dataset.drawingEventsBound === '1') {
          return;
        }
        
        const ctx = canvas.getContext('2d');
        const ctxPrev = preview.getContext('2d');
        let drawing = false;
        let start = {x:0, y:0};

        function strokeLine(from, to, mode){
          ctx.save();
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';
          ctx.lineWidth = currentSize;
          if (mode === 'eraser') {
            ctx.globalCompositeOperation = 'destination-out';
            ctx.strokeStyle = 'rgba(0,0,0,1)';
          } else {
            ctx.globalCompositeOperation = 'source-over';
            ctx.strokeStyle = currentColor;
          }
          ctx.beginPath();
          ctx.moveTo(from.x, from.y);
          ctx.lineTo(to.x, to.y);
          ctx.stroke();
          ctx.restore();
        }

        function drawShape(shape, from, to){
          ctxPrev.clearRect(0,0,preview.width,preview.height);
          if (!shape) return;
          const w = to.x - from.x;
          const h = to.y - from.y;
          ctxPrev.save();
          ctxPrev.lineWidth = currentSize;
          ctxPrev.strokeStyle = shape === 'eraser' ? '#000' : currentColor;
          ctxPrev.setLineDash([5,3]);
          ctxPrev.beginPath();
          if (shape === 'rect') ctxPrev.rect(from.x, from.y, w, h);
          else if (shape === 'circle') {
            const r = Math.sqrt(w*w + h*h);
            ctxPrev.arc(from.x, from.y, r, 0, Math.PI * 2);
          }
          ctxPrev.stroke();
          ctxPrev.restore();
        }

        function commitShape(shape, from, to){
          ctxPrev.clearRect(0,0,preview.width,preview.height);
          const w = to.x - from.x;
          const h = to.y - from.y;
          ctx.save();
          ctx.lineWidth = currentSize;
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';
          if (shape === 'eraser') {
            ctx.globalCompositeOperation = 'destination-out';
            ctx.strokeStyle = '#000';
          } else {
            ctx.globalCompositeOperation = 'source-over';
            ctx.strokeStyle = currentColor;
          }
          ctx.beginPath();
          if (shape === 'rect') ctx.rect(from.x, from.y, w, h);
          else if (shape === 'circle') {
            const r = Math.sqrt(w*w + h*h);
            ctx.arc(from.x, from.y, r, 0, Math.PI * 2);
          }
          ctx.stroke();
          ctx.restore();
        }

        function onDown(e){
          // Only respond to mouse button 0 (left click) or touch
          if (e.button !== 0 && e.button !== undefined && e.type !== 'touchstart') return;
          
          // Check if clicking on a token - if so, ignore and let token drag happen
          const target = e.target;
          if (target && target.closest && target.closest('.mapa-token')) return;
          
          e.preventDefault();
          e.stopPropagation();
          drawing = true;
          start = toCoord(e, mapaArea);
          mapaArea.dataset.drawing = '1';
          
          // Try to set pointer capture if available
          if (e.pointerId !== undefined && canvas.setPointerCapture) {
            try { canvas.setPointerCapture(e.pointerId); } catch(_){}
          }
          
          // desenha um ponto imediato para feedback
          strokeLine(start, start, currentMode);
        }

        function onMove(e){
          if (!drawing) return;
          e.preventDefault();
          e.stopPropagation();
          const pos = toCoord(e, mapaArea);
          if (currentMode === 'pen' || currentMode === 'eraser') {
            const prev = start;
            strokeLine(prev, pos, currentMode);
            start = pos;
          } else {
            drawShape(currentMode, start, pos);
          }
        }

        function onUp(e){
          if (!drawing) return;
          e.preventDefault();
          e.stopPropagation();
          const pos = toCoord(e, mapaArea);
          // Salva apenas traços completos ao soltar o mouse
          if (currentMode === 'pen' || currentMode === 'eraser') {
            strokeLine(start, pos, currentMode);
          } else {
            commitShape(currentMode, start, pos);
          }
          // Captura snapshot do canvas e salva de uma vez
          setTimeout(() => salvarCanvasCompleto(mapaArea), 50);
          drawing = false;
          delete mapaArea.dataset.drawing;
          if (e.pointerId !== undefined && canvas.releasePointerCapture) {
            try { canvas.releasePointerCapture(e.pointerId); } catch(_){ }
          }
        }

        // Attach event listeners to mapaArea (parent), not canvas
        // This captures all events in the area and lets us dispatch to canvas
        mapaArea.addEventListener('pointerdown', onDown, false);
        mapaArea.addEventListener('mousedown', onDown, false);
        mapaArea.addEventListener('touchstart', onDown, { passive: false });
        
        mapaArea.addEventListener('pointermove', onMove, false);
        mapaArea.addEventListener('mousemove', onMove, false);
        mapaArea.addEventListener('touchmove', onMove, { passive: false });
        
        mapaArea.addEventListener('pointerup', onUp, false);
        mapaArea.addEventListener('mouseup', onUp, false);
        mapaArea.addEventListener('touchend', onUp, { passive: false });
        
        mapaArea.addEventListener('pointercancel', onUp, false);

        canvas.dataset.drawingBound = '1';
        mapaArea.dataset.drawBound = '1';
        mapaArea.dataset.drawingEventsBound = '1';
      }
      
      // Helper to clone and replace canvas to remove all event listeners
      function resetCanvasEventListeners(canvas) {
        const newCanvas = canvas.cloneNode(true);
        newCanvas.dataset.drawingBound = '';  // Clear the flag
        canvas.parentNode.replaceChild(newCanvas, canvas);
        return newCanvas;
      }

      function ensureDrawLayersAll(){
        document.querySelectorAll("[id^='mapa-area-']").forEach(ensureDrawLayer);
      }

      function updateDrawLayerSizes(){
        document.querySelectorAll("[id^='mapa-area-']").forEach(mapaArea => {
          const c = mapaArea.querySelector('.mapa-draw-layer');
          const p = mapaArea.querySelector('.mapa-draw-preview');
          if (c && p) resizeCanvasPair(mapaArea, c, p);
        });
      }
      // Exposto para callbacks externos (zoom/pan)
      window.updateDrawLayerSizes = updateDrawLayerSizes;
      window.ensureDrawLayersAll = ensureDrawLayersAll;

      function clearAllDrawings(){
        document.querySelectorAll('.mapa-draw-layer').forEach(cv => cv.getContext('2d').clearRect(0,0,cv.width,cv.height));
        document.querySelectorAll('.mapa-draw-preview').forEach(cv => cv.getContext('2d').clearRect(0,0,cv.width,cv.height));
        // Limpa no servidor também
        const area = document.querySelector("[id^='mapa-area-']");
        if (area) {
          const mapaId = area.id.replace('mapa-area-','');
          fetch(`/combate/mapa/${mapaId}/limpar-desenhos/`, {
            method: 'POST',
            headers: {
              'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value,
            },
            credentials: 'same-origin',
          }).catch(err => console.warn('Falha ao limpar desenhos:', err));
        }
      }

      function setupToolbar(){
        const tb = document.querySelector('.mapa-draw-toolbar');
        if (!tb || tb.dataset.bound) return;
        
        // Restore saved color selection
        const firstColor = tb.querySelector(`[data-draw-color="${currentColor}"]`) || tb.querySelector('[data-draw-color]');
        if (firstColor) firstColor.classList.add('active');
        
        // Restore saved mode selection (not always pen)
        const savedModeBtn = tb.querySelector(`[data-draw-mode="${currentMode}"]`);
        setActiveMode(savedModeBtn || tb.querySelector('[data-draw-mode="pen"]'));
        
        tb.addEventListener('click', (e)=>{
          const modeBtn = e.target.closest('[data-draw-mode]');
          const colorBtn = e.target.closest('[data-draw-color]');
          if (modeBtn){
            currentMode = modeBtn.dataset.drawMode;
            setActiveMode(modeBtn);
            try { localStorage.setItem(DRAW_MODE_KEY, currentMode); } catch(_) {}
          }
          if (colorBtn){
            currentColor = colorBtn.dataset.drawColor;
            tb.querySelectorAll('[data-draw-color]').forEach(b=>b.classList.remove('active'));
            colorBtn.classList.add('active');
            try { localStorage.setItem(DRAW_COLOR_KEY, currentColor); } catch(_) {}
          }
        });
        const sizeSel = tb.querySelector('#mdt-size');
        if (sizeSel) sizeSel.addEventListener('change', ()=>{ currentSize = parseInt(sizeSel.value, 10) || 4; });
        const clearBtn = tb.querySelector('#mdt-clear');
        if (clearBtn) clearBtn.addEventListener('click', clearAllDrawings);
        tb.dataset.bound = '1';
      }

      window.setupMapDrawToolbar = setupToolbar;

      document.addEventListener('DOMContentLoaded', function(){
        setupToolbar();
        // Force immediate canvas creation
        ensureDrawLayersAll();
        updateDrawLayerSizes();
        // Carrega desenhos salvos do servidor
        try {
          const desenhosSalvos = {{ desenhos_salvos|safe }};
          Object.entries(desenhosSalvos).forEach(([mapaId, snapshots]) => {
            const area = document.getElementById('mapa-area-' + mapaId);
            if (!area || !Array.isArray(snapshots) || !snapshots.length) return;
            const canvas = area.querySelector('.mapa-draw-layer');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            // Carrega último snapshot (imagem completa)
            const last = snapshots[snapshots.length - 1];
            if (last && last.type === 'snapshot' && last.data) {
              const img = new Image();
              img.onload = () => {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
              };
              img.src = last.data;
            }
          });
        } catch(_) {}
        // Re-ensure after images load
        document.querySelectorAll('.mapa-img').forEach(img => {
          if (img.complete) { 
            ensureDrawLayersAll(); 
            updateDrawLayerSizes(); 
            return; 
          }
          img.addEventListener('load', function(){ 
            ensureDrawLayersAll(); 
            updateDrawLayerSizes(); 
          }, { once:true });
        });
        // Extra safety: ensure one more time after a short delay
        setTimeout(() => {
          ensureDrawLayersAll();
          updateDrawLayerSizes();
        }, 100);
      });

      window.addEventListener('resize', updateDrawLayerSizes);

      // Hook nas funções existentes de resize/zoom
      const prevEnsure = window.ensureAllAreasMinScale;
      window.ensureAllAreasMinScale = function(){
        if (typeof prevEnsure === 'function') prevEnsure();
        updateDrawLayerSizes();
        ensureDrawLayersAll();
      };
    })();
    // ====== Persistência do tamanho dos tokens (Ctrl + Scroll) ======
    function applyRemoteDraw(evt){
      try {
        if (!evt || !evt.mapa_id) return;
        if (evt.client_id && window.DRAW_CLIENT_ID && evt.client_id === window.DRAW_CLIENT_ID) return;
        const area = document.getElementById('mapa-area-' + evt.mapa_id);
        if (!area) return;
        if (window.ensureDrawLayersAll) window.ensureDrawLayersAll();
        const canvas = area.querySelector('.mapa-draw-layer');
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        const mode = evt.mode || 'pen';
        const color = evt.color || '#d33';
        const size = Number(evt.size) || 4;
        const from = evt.from || {}; const to = evt.to || {};
        if (typeof from.x !== 'number' || typeof from.y !== 'number' || typeof to.x !== 'number' || typeof to.y !== 'number') return;
        ctx.save();
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.lineWidth = size;
        if (mode === 'eraser') {
          ctx.globalCompositeOperation = 'destination-out';
          ctx.strokeStyle = '#000';
        } else {
          ctx.globalCompositeOperation = 'source-over';
          ctx.strokeStyle = color;
        }
        ctx.beginPath();
        if (mode === 'rect') {
          ctx.rect(from.x, from.y, to.x - from.x, to.y - from.y);
        } else if (mode === 'circle') {
          const dx = to.x - from.x; const dy = to.y - from.y;
          const r = Math.sqrt(dx*dx + dy*dy);
          ctx.arc(from.x, from.y, r, 0, Math.PI * 2);
        } else {
          ctx.moveTo(from.x, from.y);
          ctx.lineTo(to.x, to.y);
        }
        ctx.stroke();
        ctx.restore();
      } catch(_) {}
    }
    function tokenSizeKey(posicaoId){ return `combate:${combateId}:token:${posicaoId}:size`; }
    function persistTokenSize(tokenEl){
      if (!tokenEl || !tokenEl.id) return;
      const id = (tokenEl.id || '').replace('token-','');
      try {
        const w = parseFloat(getComputedStyle(tokenEl).width) || 40;
        localStorage.setItem(tokenSizeKey(id), String(Math.round(w)));
      } catch(_) {}
    }
    function restoreTokenSize(tokenEl){
      if (!tokenEl || !tokenEl.id) return;
      const id = (tokenEl.id || '').replace('token-','');
      try {
        const saved = parseFloat(localStorage.getItem(tokenSizeKey(id)) || '');
        if (Number.isFinite(saved) && saved > 0) {
          tokenEl.style.width = saved + 'px';
          tokenEl.style.height = saved + 'px';
        }
      } catch(_) {}
    }
    function restoreTokenSizes(scope){
      (scope || document).querySelectorAll('.mapa-token').forEach(restoreTokenSize);
    }
    // ====== Persistência de selects sujeitos a refresh (mapa/add participante/NPC) ======
    function persistSelectById(id, key){
      const el = document.getElementById(id);
      if (!el) return;
      // Restore saved value
      try {
        const saved = localStorage.getItem(key);
        if (saved) {
          for (let i=0;i<el.options.length;i++) {
            if (String(el.options[i].value) === String(saved)) { el.selectedIndex = i; break; }
          }
        }
      } catch(_) {}
      if (!el.dataset.persistBound) {
        el.addEventListener('change', () => { try { localStorage.setItem(key, String(el.value||'')); } catch(_) {} });
        el.dataset.persistBound = '1';
      }
    }
    function setupGridControls(){
      const cb = document.getElementById('grid-enable');
      const sel = document.getElementById('grid-size');
      // Restaura estado salvo (se houver)
      restoreGridStateIfNeeded();
      if (cb && !cb.dataset.bound){
        cb.addEventListener('change', () => { persistGridState(); updateAllGrids(); });
        cb.dataset.bound = '1';
      }
      if (sel && !sel.dataset.bound){
        sel.addEventListener('change', () => { persistGridState(); updateAllGrids(); });
        sel.dataset.bound = '1';
      }
    }

  // Torna helpers acessíveis globalmente para outros blocos/scripts
  window.gridEnabled = gridEnabled;
  window.getGridSize = getGridSize;
  window.applyGridSnap = applyGridSnap;
  window.updateGridForArea = updateGridForArea;
  window.updateAllGrids = updateAllGrids;
  window.setupGridControls = setupGridControls;

    // ====== Persistência de estado do mapa (zoom/scroll) ======
    function saveMapStates(){
      const states = {};
      document.querySelectorAll("[id^='mapa-area-']").forEach(area => {
        const id = (area.id || '').replace('mapa-area-','');
        states[id] = {
          scale: parseFloat(area.dataset.scale || '1') || 1,
          scrollLeft: area.scrollLeft || 0,
          scrollTop: area.scrollTop || 0,
        };
      });
      window._mapStates = states;
    }
    function snapshotDrawings(){
      const snaps = {};
      document.querySelectorAll("[id^='mapa-area-']").forEach(area => {
        const id = area.id || '';
        const canvas = area.querySelector('.mapa-draw-layer');
        if (canvas && canvas.width && canvas.height) {
          try {
            snaps[id] = {
              w: canvas.width,
              h: canvas.height,
              data: canvas.toDataURL('image/png')
            };
          } catch(_) {}
        }
      });
      window._drawSnaps = snaps;
    }
    function restoreDrawings(){
      const snaps = window._drawSnaps || {};
      Object.entries(snaps).forEach(([id, snap]) => {
        const area = document.getElementById(id);
        const canvas = area ? area.querySelector('.mapa-draw-layer') : null;
        if (!canvas || !snap || !snap.data) return;
        const ctx = canvas.getContext('2d');
        const img = new Image();
        img.onload = () => {
          try {
            ctx.clearRect(0,0,canvas.width,canvas.height);
            ctx.drawImage(img, 0, 0, snap.w, snap.h, 0, 0, canvas.width, canvas.height);
          } catch(_) {}
        };
        img.src = snap.data;
      });
    }
    function restoreMapStates(){
      const states = window._mapStates || {};
      document.querySelectorAll("[id^='mapa-area-']").forEach(area => {
        const id = (area.id || '').replace('mapa-area-','');
        const st = states[id];
        const canvas = area.querySelector('.mapa-canvas');
        const img = canvas ? canvas.querySelector('.mapa-img') : null;
        if (!st || !canvas || !img) return;
        let scale = parseFloat(st.scale || 1) || 1;
        // Recalcula limites dinâmicos e aplica transform
        const rect = canvas.getBoundingClientRect();
        const baseW = img.naturalWidth || img.clientWidth || rect.width || 1;
        const baseH = img.naturalHeight || img.clientHeight || rect.height || 1;
        const areaW = area.clientWidth || 1;
        const areaH = area.clientHeight || 1;
        const fitW = areaW / (baseW || areaW);
        const fitH = areaH / (baseH || areaH);
  // Permite upscaling quando a imagem é menor que a área visível
  const minScale = Math.max(fitW, fitH);
        const maxScale = 3;
        scale = Math.max(minScale, Math.min(maxScale, scale));
        area.dataset.scale = String(scale);
        canvas.style.transform = `scale(${scale})`;
        canvas.style.minWidth = (baseW * scale) + 'px';
        canvas.style.minHeight = (baseH * scale) + 'px';
        // Restaura scroll (com clamp natural pelos bounds atuais)
        area.scrollLeft = st.scrollLeft || 0;
        area.scrollTop = st.scrollTop || 0;
        if (typeof updateGridForArea === 'function') updateGridForArea(area);
      });
    }

    // Utilitários para refresh parcial
    async function fetchPageDOM() {
      const resp = await fetch(window.location.href, { cache: 'no-store' });
      const html = await resp.text();
      const parser = new DOMParser();
      return parser.parseFromString(html, 'text/html');
    }
  async function refreshSelectors(selectors) {
      try {
        // Guarda posição global de scroll para evitar "pulos" ao fim da página
        const prevDocHeight = document.body.scrollHeight;
        const prevBottomGap = Math.max(0, prevDocHeight - (window.scrollY + window.innerHeight));
        const wasDocNearBottom = prevBottomGap < 32; // 32px do fim consideramos "no fundo"
        // Garante que a preferência atual da grade não se perca durante o refresh
        persistGridState();
        // Salva estados atuais do mapa (zoom/scroll) para restaurar após troca
        saveMapStates();
        // Snapshot drawings para restaurar após troca
        snapshotDrawings();
        // Hist: detecta se o usuário está perto do fim para preservar leitura SOMENTE se vamos trocar o #historico-card
        let historicoWasNearBottom = false;
        let historicoPrevScroll = 0;
        let willReplaceHistorico = !!(selectors||[]).includes('#historico-card');
        try {
          if (willReplaceHistorico) {
            const hc = document.getElementById('historico-card');
            if (hc) {
              historicoWasNearBottom = (hc.scrollHeight - hc.scrollTop - hc.clientHeight) < 24;
              historicoPrevScroll = hc.scrollTop || 0;
            }
          }
        } catch(_) {}
        // Preserva seleção de alvos quando o formulário de ataque for atualizado
        let savedAlvos = null;
        try {
          if ((selectors || []).some(s => s === '#form-ataque')) {
            const alvoSel = document.getElementById('alvo');
            if (alvoSel) {
              savedAlvos = Array.from(alvoSel.selectedOptions || []).map(o => String(o.value));
            }
          }
        } catch(_) {}
        const doc = await fetchPageDOM();
        // Prepare nodes once to avoid parent/child conflicts
        const items = [];
        const uniq = Array.from(new Set(selectors || []));
        for (const sel of uniq) {
          const fresh = doc.querySelector(sel);
          if (fresh) {
            // Compute depth for ordering (parents first)
            let d = 0, n = fresh;
            while (n && n.parentElement) { d++; n = n.parentElement; }
            items.push({ sel, fresh, depth: d });
          }
        }
        // Remove descendants when their ancestor is already scheduled
        items.sort((a,b)=>a.depth-b.depth);
        const filtered = [];
        for (let i=0;i<items.length;i++){
          let isDescendant = false;
          for (let j=0;j<filtered.length && !isDescendant;j++){
            if (filtered[j].fresh.contains(items[i].fresh)) isDescendant = true;
          }
          if (!isDescendant) filtered.push(items[i]);
        }
        // Replace in DOM using the pre-collected fresh nodes
        let replacedHistorico = false;
        for (const it of filtered) {
          const target = document.querySelector(it.sel);
          if (target && it.fresh) {
            if (it.sel === '#historico-card') replacedHistorico = true;
            target.replaceWith(it.fresh);
          }
        }
  // NÃO reaplica equalizarAlturas durante refresh para evitar mapa crescer ao atualizar histórico
  // rafEqualize() será chamado apenas em resize real (window.addEventListener('resize', rafEqualize))
  // Restaura estados do mapa após substituição
        restoreMapStates();
  // Se não houver estado salvo (primeira vez), garanta cobertura
  ensureAllAreasMinScale();
  if (window.ensureDrawLayersAll) window.ensureDrawLayersAll();
    // Restaura desenhos após substituição
    try { restoreDrawings(); } catch(_) {}
  // Reformat history for readability
  try { enhanceHistorico(document); } catch(_) {}
  // Marca interação do usuário com o histórico (usado para evitar pulo ao topo durante resize)
  try {
    const hc = document.getElementById('historico-card');
    if (hc && !hc.dataset.userBind) {
      const mark = () => { window._histUserScrollAt = Date.now(); };
      hc.addEventListener('scroll', mark, { passive:true });
      hc.addEventListener('wheel', mark, { passive:true });
      hc.addEventListener('mouseenter', mark, { passive:true });
      hc.dataset.userBind = '1';
    }
  } catch(_) {}
        // Ajuste de scroll apenas se o card foi realmente substituído
        if (replacedHistorico) {
          // Sempre faz scroll para o final do histórico após atualização
          const historico = document.getElementById('historico-card');
          if (historico) {
            // Aguarda um tick para garantir que o DOM foi renderizado
            setTimeout(() => {
              if (historico.scrollHeight > historico.clientHeight) {
                historico.scrollTop = historico.scrollHeight;
              }
            }, 0);
          }
        }
  // Rebind drag & drop após trocas da coluna direita
        rebindDragDrop();
  // Rebind ações do topo se a barra de turno foi trocada
    setupTopbarMapActions();
  // Rebind e atualizar grade
  setupGridControls();
  updateAllGrids();
  if (window.setupMapDrawToolbar) window.setupMapDrawToolbar();
  if (window.ensureDrawLayersAll) window.ensureDrawLayersAll();
  // Após re-render, restaura tamanhos salvos dos tokens
  try { restoreTokenSizes(document); } catch(_) {}
  // Rebind dos formulários para evitar navegação
  ajaxifyInteractionForms();
  // Rebind dos selects de personagem/ataque apenas se o formulário foi trocado
  try {
    const formAtaque = document.getElementById('form-ataque');
    if (formAtaque && (!formAtaque.dataset || !formAtaque.dataset.boundSync)) {
      bindPersonagemAcaoSync();
      try { if (formAtaque) formAtaque.dataset.boundSync = '1'; } catch(_) {}
    }
  } catch(_) { bindPersonagemAcaoSync(); }
  // Restaura selects persistidos
  try {
    persistSelectById('mapa_existente_top', `combate:${combateId}:mapa_existente_top`);
    persistSelectById('novo_participante', `combate:${combateId}:novo_participante`);
    persistSelectById('novo_npc', `combate:${combateId}:novo_npc`);
    // Restaura seleção de alvos após recarregar o form de ataque
    if (savedAlvos && savedAlvos.length) {
      const alvoSel2 = document.getElementById('alvo');
      if (alvoSel2) {
        Array.from(alvoSel2.options).forEach(o => { o.selected = savedAlvos.indexOf(String(o.value)) !== -1; });
      }
    }
  } catch(_) {}
  // Reaplica label do turno ativo se houver valor server-side mais preciso
  try {
    if (window._lastTurnDisplayNome) {
      const el = document.getElementById('turno-ativo-nome');
      if (el) el.textContent = window._lastTurnDisplayNome;
    }
  } catch(_) {}
        // Restaura posição de scroll global se estava próximo ao fim
        if (replacedHistorico || (selectors||[]).includes('#historico-card')) {
          try {
            const newDocHeight = document.body.scrollHeight;
            const targetGap = wasDocNearBottom ? 0 : prevBottomGap;
            const targetY = Math.max(0, newDocHeight - window.innerHeight - targetGap);
            window.scrollTo({ top: targetY, behavior: 'auto' });
          } catch(_) {}
        }
      } catch (err) {
        console.warn('Refresh parcial falhou, mantendo página:', err);
      }
    }
    function rebindDragDrop(){
      document.querySelectorAll("[id^='mapa-area-']").forEach(function(mapaArea) {
        const canvas = mapaArea.querySelector('.mapa-canvas');
        
        mapaArea.addEventListener('dragover', function(e){ e.preventDefault(); });
        mapaArea.addEventListener('drop', function(e){
          e.preventDefault();
          const canvas = mapaArea.querySelector('.mapa-canvas');
          if (!canvas) return;
          const tokenId = e.dataTransfer.getData('tokenId');
          const rect = canvas.getBoundingClientRect();
          const scale = parseFloat(mapaArea.dataset.scale || '1');
          const tokenEl = document.getElementById('token-' + tokenId);
          const tokenSize = tokenEl ? parseFloat(getComputedStyle(tokenEl).width) || 40 : 40;
          const half = tokenSize / 2;
          let x = (e.clientX - rect.left - half) / scale;
          let y = (e.clientY - rect.top - half) / scale;
          // Clamp to image bounds (pre-transform coordinates)
          const img = canvas.querySelector('.mapa-img');
          const baseW = img ? (img.naturalWidth || img.clientWidth) : 0;
          const baseH = img ? (img.naturalHeight || img.clientHeight) : 0;
          if (baseW && baseH) {
            x = Math.max(0, Math.min(baseW - tokenSize, x));
            y = Math.max(0, Math.min(baseH - tokenSize, y));
          }
          // Snap opcional à grade
          if (gridEnabled()) { const snapped = applyGridSnap(x, y); x = snapped.x; y = snapped.y; }
          fetch(`/combate/atualizar-posicao-token/${tokenId}/`, {
            method: 'POST',
            headers: { 'X-CSRFToken': '{{ csrf_token }}', 'Content-Type': 'application/json' },
            credentials: 'same-origin',
            body: JSON.stringify({x,y})
          }).then(() => {
            const token = document.getElementById('token-' + tokenId);
            if (token) { token.style.left = x + 'px'; token.style.top = y + 'px'; }
          });
        });

        // Per-token resize with Ctrl + wheel over the token
        function bindTokenWheelResize() {
          mapaArea.querySelectorAll('.mapa-token').forEach(token => {
            if (token.dataset.wheelResized) return;
            token.addEventListener('wheel', function(e){
              if (!e.ctrlKey) return; // only when holding Ctrl
              e.preventDefault();
              e.stopPropagation();
              e.stopImmediatePropagation();
              const cs = getComputedStyle(token);
              const cur = parseFloat(cs.width) || 40;
              const dir = e.deltaY > 0 ? -1 : 1;
              const factor = dir > 0 ? 1.1 : 1/1.1;
              let next = +(cur * factor).toFixed(2);
              const min = 20, max = 120;
              next = Math.max(min, Math.min(max, next));
              token.style.width = next + 'px';
              token.style.height = next + 'px';
              try { persistTokenSize(token); } catch(_) {}
              // Persiste no servidor também
              try {
                const id = (token.id || '').replace('token-','');
                fetch(`/combate/atualizar-posicao-token/${id}/`, {
                  method: 'POST',
                  headers: { 'X-CSRFToken': '{{ csrf_token }}', 'Content-Type': 'application/json' },
                  credentials: 'same-origin',
                  body: JSON.stringify({ size: next })
                }).catch(()=>{});
              } catch(_) {}
            }, { passive: false });
            token.dataset.wheelResized = '1';
            try { restoreTokenSize(token); } catch(_) {}
          });
        }
        bindTokenWheelResize();

        // Helper function to calculate minimum scale to cover viewport
        function minScale(){
          const canvas = mapaArea.querySelector('.mapa-canvas');
          const img = canvas ? canvas.querySelector('.mapa-img') : null;
          if (!canvas || !img) return 1;
          const baseW = parseFloat(canvas.dataset.baseWidth) || img.naturalWidth || img.clientWidth || 0;
          const baseH = parseFloat(canvas.dataset.baseHeight) || img.naturalHeight || img.clientHeight || 0;
          const viewportW = mapaArea.clientWidth || 0;
          const viewportH = mapaArea.clientHeight || 0;
          if (baseW > 0 && baseH > 0 && viewportW > 0 && viewportH > 0) {
            const minVal = Math.max(viewportW / baseW, viewportH / baseH);
            return minVal;
          }
          return 1;
        }

        // Helper function to clamp scroll position
        function clampScroll(){
          const canvas = mapaArea.querySelector('.mapa-canvas');
          const img = canvas ? canvas.querySelector('.mapa-img') : null;
          if (!img) return;
          const scale = parseFloat(mapaArea.dataset.scale || '1') || 1;
          const baseW = parseFloat(canvas.dataset.baseWidth || canvas.offsetWidth || 0);
          const baseH = parseFloat(canvas.dataset.baseHeight || canvas.offsetHeight || 0);
          const contentW = baseW * scale;
          const contentH = baseH * scale;
          const maxLeft = Math.max(0, contentW - mapaArea.clientWidth);
          const maxTop = Math.max(0, contentH - mapaArea.clientHeight);
          mapaArea.scrollLeft = Math.min(mapaArea.scrollLeft, maxLeft);
          mapaArea.scrollTop = Math.min(mapaArea.scrollTop, maxTop);
        }

        // Helper to set scale, expand scrollable area, and keep pointer focus (if pivot provided)
        function setScale(newScale, pivotEvent){
          const canvas = mapaArea.querySelector('.mapa-canvas');
          const img = canvas ? canvas.querySelector('.mapa-img') : null;
          if (!canvas || !img) return;
          const overlay = mapaArea.querySelector('.mapa-draw-layer');
          const overlayPrev = mapaArea.querySelector('.mapa-draw-preview');
          const oldScale = parseFloat(mapaArea.dataset.scale || '1');
          // Base (natural) size - store once and reuse
          if (!canvas.dataset.baseWidth || !canvas.dataset.baseHeight) {
            canvas.dataset.baseWidth = img.naturalWidth || img.clientWidth || img.offsetWidth;
            canvas.dataset.baseHeight = img.naturalHeight || img.clientHeight || img.offsetHeight;
          }
          const baseW = parseFloat(canvas.dataset.baseWidth) || 1;
          const baseH = parseFloat(canvas.dataset.baseHeight) || 1;
          // Calculate minimum scale to cover viewport and clamp
          const minScaleVal = minScale();
          const maxScale = 3;
          newScale = Math.max(minScaleVal, Math.min(maxScale, newScale));
          // Apply transform and enlarge scrollable box so scrollbars match zoom
          mapaArea.dataset.scale = String(newScale);
          canvas.style.transform = `scale(${newScale})`;
          canvas.style.minWidth = (baseW * newScale) + 'px';
          canvas.style.minHeight = (baseH * newScale) + 'px';
          // Atualiza grade com novo zoom
          updateGridForArea(mapaArea);
          if (overlay && overlayPrev) {
            if (window.resizeCanvasPair) window.resizeCanvasPair(mapaArea, overlay, overlayPrev);
          }
          if (window.updateDrawLayerSizes) window.updateDrawLayerSizes();
          
          // Clamp scroll after transform
          clampScroll();

          // Preserve focal point under cursor if event provided
          if (pivotEvent) {
            const areaRect = mapaArea.getBoundingClientRect();
            const pointerX = pivotEvent.clientX - areaRect.left;
            const pointerY = pivotEvent.clientY - areaRect.top;
            const sx = mapaArea.scrollLeft;
            const sy = mapaArea.scrollTop;
            const nx = (sx + pointerX) * (newScale / oldScale) - pointerX;
            const ny = (sy + pointerY) * (newScale / oldScale) - pointerY;
            const maxScrollX = Math.max(0, mapaArea.scrollWidth - mapaArea.clientWidth);
            const maxScrollY = Math.max(0, mapaArea.scrollHeight - mapaArea.clientHeight);
            mapaArea.scrollLeft = Math.min(maxScrollX, Math.max(0, nx));
            mapaArea.scrollTop = Math.min(maxScrollY, Math.max(0, ny));
          }
        }

        // Initialize dimensions and scale when image loads
        const img = canvas ? canvas.querySelector('.mapa-img') : null;
        if (img) {
          function initDimensions(){
            const w = img.naturalWidth || img.width || 0;
            const h = img.naturalHeight || img.height || 0;
            if (w && h) {
              canvas.dataset.baseWidth = w;
              canvas.dataset.baseHeight = h;
              setScale(parseFloat(mapaArea.dataset.scale || '1') || 1);
            }
          }
          if (img.complete) {
            initDimensions();
          } else {
            img.addEventListener('load', initDimensions);
          }
        }

        // Zoom controls removed - use Ctrl+Scroll

        // Clamp scroll so it never goes beyond the scaled image area
        if (!mapaArea.dataset.scrollBound) {
          mapaArea.addEventListener('scroll', function(){
            requestAnimationFrame(function(){
              const canvas = mapaArea.querySelector('.mapa-canvas');
              const img = canvas ? canvas.querySelector('.mapa-img') : null;
              if (!img) return;
              const scale = parseFloat(mapaArea.dataset.scale || '1');
              const baseW = img.naturalWidth || img.clientWidth || 0;
              const baseH = img.naturalHeight || img.clientHeight || 0;
              const contentW = baseW * scale;
              const contentH = baseH * scale;
              const maxX = Math.max(0, contentW - mapaArea.clientWidth);
              const maxY = Math.max(0, contentH - mapaArea.clientHeight);
              if (mapaArea.scrollLeft > maxX) mapaArea.scrollLeft = maxX;
              if (mapaArea.scrollTop > maxY) mapaArea.scrollTop = maxY;
              if (mapaArea.scrollLeft < 0) mapaArea.scrollLeft = 0;
              if (mapaArea.scrollTop < 0) mapaArea.scrollTop = 0;
            });
          }, { passive: true });
          mapaArea.dataset.scrollBound = '1';
        }

        // Panning: Middle mouse or Space + Left drag
        function clampScrollToBounds() {
          const canvas = mapaArea.querySelector('.mapa-canvas');
          const img = canvas ? canvas.querySelector('.mapa-img') : null;
          if (!img) return;
          const scale = parseFloat(mapaArea.dataset.scale || '1');
          const baseW = img.naturalWidth || img.clientWidth || 0;
          const baseH = img.naturalHeight || img.clientHeight || 0;
          const maxX = Math.max(0, baseW * scale - mapaArea.clientWidth);
          const maxY = Math.max(0, baseH * scale - mapaArea.clientHeight);
          if (mapaArea.scrollLeft > maxX) mapaArea.scrollLeft = maxX;
          if (mapaArea.scrollTop > maxY) mapaArea.scrollTop = maxY;
          if (mapaArea.scrollLeft < 0) mapaArea.scrollLeft = 0;
          if (mapaArea.scrollTop < 0) mapaArea.scrollTop = 0;
        }

        function bindPan(){
          if (!window._mapPanKeyBound) {
            window._mapSpacePressed = false;
            window.addEventListener('keydown', (ev)=>{ if (ev.code === 'Space') { window._mapSpacePressed = true; ev.preventDefault(); } }, { capture:true });
            window.addEventListener('keyup', (ev)=>{ if (ev.code === 'Space') { window._mapSpacePressed = false; ev.preventDefault(); } }, { capture:true });
            window._mapPanKeyBound = true;
          }
          if (mapaArea.dataset.panBound) return;
          let panning = false, startX = 0, startY = 0, startL = 0, startT = 0;
          function onMove(ev){
            if (!panning) return;
            const dx = ev.clientX - startX;
            const dy = ev.clientY - startY;
            mapaArea.scrollLeft = startL - dx;
            mapaArea.scrollTop = startT - dy;
            clampScrollToBounds();
          }
          function endPan(){
            if (!panning) return;
            panning = false;
            mapaArea.classList.remove('panning');
            window.removeEventListener('mousemove', onMove, true);
            window.removeEventListener('mouseup', endPan, true);
          }
          mapaArea.addEventListener('mousedown', function(ev){
            if (mapaArea.dataset.drawing === '1') return; // não pan enquanto desenhando
            const isMiddle = ev.button === 1;
            const isSpaceDrag = ev.button === 0 && window._mapSpacePressed;
            if (!isMiddle && !isSpaceDrag) return;
            ev.preventDefault();
            ev.stopPropagation();
            panning = true;
            startX = ev.clientX; startY = ev.clientY;
            startL = mapaArea.scrollLeft; startT = mapaArea.scrollTop;
            mapaArea.classList.add('panning');
            window.addEventListener('mousemove', onMove, true);
            window.addEventListener('mouseup', endPan, true);
          }, { capture:true });
          // Prevent token drag when holding space
          mapaArea.addEventListener('dragstart', function(ev){ if (window._mapSpacePressed) { ev.preventDefault(); ev.stopImmediatePropagation(); } }, true);
          mapaArea.dataset.panBound = '1';
        }
        bindPan();

        // Ctrl + wheel zoom (once)
        if (!mapaArea.dataset.wheelBound) {
          mapaArea.addEventListener('wheel', function(e){
            if (!e.ctrlKey) return;
            e.preventDefault();
            let scale = parseFloat(mapaArea.dataset.scale || '1');
            const dir = e.deltaY > 0 ? -1 : 1; // up = zoom in
            const factor = dir > 0 ? 1.1 : 1/1.1;
            scale = +(scale * factor).toFixed(3);
            setScale(scale, e);
          }, { passive: false });
          mapaArea.dataset.wheelBound = '1';
        }
      });
    }

    // ====== Helpers globais para atualizar selects (Alvos e Ações de) ======
    function buildDisplayNome(part){
      try {
        if (!part) return '';
        const idStr = String(part.id || '');
        const idx = Number(part.nome_ordem || part.idx || part.ordem || 1);
        const base = part.display_nome || part.nome || `#${idStr}`;
        if (!base) return `#${idStr}`;
        // Se o backend já enviou display_nome, preserve exatamente
        if (part.display_nome) return base;
        // Evita duplicar sufixo se o nome já contém o índice
        if (idx > 1 && !base.includes(`(${idx})`)) return `${base} (${idx})`;
        return base;
      } catch(_) { return ''; }
    }
    function ensureAlvoHasParticipant(part){
      try {
        const sel = document.getElementById('alvo');
        if (!sel || !part) return;
        if (window._isPersonagemAllowed && !window._isPersonagemAllowed(part.personagem_id)) return;
        const idStr = String(part.id);
        const exists = Array.from(sel.options).some(o => String(o.value) === idStr);
        if (!exists) {
          const opt = document.createElement('option');
          opt.value = idStr;
          const nome = buildDisplayNome(part) || `#${idStr}`;
          const init = (typeof part.iniciativa !== 'undefined' && part.iniciativa !== null) ? part.iniciativa : '';
          opt.textContent = init !== '' ? `[Init ${init}] ${nome}` : nome;
          sel.appendChild(opt);
        }
      } catch(_) {}
    }
    // Atualização leve: busca JSON de participantes e só mexe nos selects se houve mudança (evita piscar)
    let _lastParticipantsSig = '';
    async function tryUpdateTargetsLight(){
      try {
        const resp = await fetch(`/combate/${combateId}/participantes-json/?_=${Date.now()}` , {cache:'no-store'});
        if (!resp.ok) return;
        const data = await resp.json();
        if (!data || !Array.isArray(data.participantes)) return;
        // Gera assinatura para detectar mudança relevante
        const filtered = data.participantes.filter(p => !window._isPersonagemAllowed || window._isPersonagemAllowed(p.personagem_id));
        const sig = filtered
          .slice()
          .sort((a,b) => (b.iniciativa||0) - (a.iniciativa||0))
          .map(p => `${p.id}:${p.nome}:${p.iniciativa||0}`)
          .join('|');
        if (sig === _lastParticipantsSig) return; // nada mudou
        _lastParticipantsSig = sig;
        const alvoSel = document.getElementById('alvo');
        if (alvoSel) {
          const prevScroll = alvoSel.scrollTop;
          const selected = new Set(Array.from(alvoSel.selectedOptions||[]).map(o=>String(o.value)));
          // Reconstrói mantendo seleção, ordenado por iniciativa desc
          alvoSel.innerHTML = '';
          const ordered = filtered.slice().sort((a,b) => (b.iniciativa||0) - (a.iniciativa||0));
          ordered.forEach(p => {
            const opt = document.createElement('option');
            opt.value = p.id;
            const nome = buildDisplayNome(p) || `#${p.id}`;
            const init = (typeof p.iniciativa !== 'undefined' && p.iniciativa !== null) ? p.iniciativa : '';
            opt.textContent = init !== '' ? `[Init ${init}] ${nome}` : nome;
            if (selected.has(String(p.id))) opt.selected = true;
            alvoSel.appendChild(opt);
          });
          // Restaura scroll anterior
          try { alvoSel.scrollTop = prevScroll; } catch(_) {}
        }
        // Se GM: atualiza "Ações de" apenas se lista mudou (mantém seleção caso id ainda exista)
        if (IS_GM) {
          const acaoSel = document.getElementById('personagem_acao');
            if (acaoSel) {
              const current = String(acaoSel.value||'');
              const existingIds = new Set(Array.from(acaoSel.options).map(o=>String(o.value)));
              const needRebuild = filtered.length !== existingIds.size || filtered.some(p=>!existingIds.has(String(p.id)));
              if (needRebuild) {
                const prevVal = current;
                acaoSel.innerHTML='';
                filtered.forEach(p=>{
                  const opt = document.createElement('option');
                  const nome = buildDisplayNome(p) || `#${p.id}`;
                  opt.value = p.id; opt.textContent = nome; opt.dataset.personagemId = p.personagem_id; opt.setAttribute('data-personagem-id', p.personagem_id); acaoSel.appendChild(opt);
                });
                // Restaura seleção
                for (let i=0;i<acaoSel.options.length;i++){ if (String(acaoSel.options[i].value)===prevVal){ acaoSel.selectedIndex=i; break; } }
                acaoSel.dispatchEvent(new Event('change'));
              }
            }
        }
      } catch(_) {}
    }
    function maybeAddToAcoesDe(part){
      if (!IS_GM || !part) return;
      try {
        if (window._isPersonagemAllowed && !window._isPersonagemAllowed(part.personagem_id)) return;
        const sel = document.getElementById('personagem_acao');
        if (!sel) return;
        const idStr = String(part.id);
        const exists = Array.from(sel.options).some(o => String(o.value) === idStr);
        if (!exists) {
          const opt = document.createElement('option');
          opt.value = idStr;
          opt.dataset.personagemId = String(part.personagem_id || '');
          opt.setAttribute('data-personagem-id', String(part.personagem_id || ''));
          opt.textContent = buildDisplayNome(part) || `#${idStr}`;
          sel.appendChild(opt);
        }
      } catch(_) {}
    }
    function removeFromAlvo(id){
      try {
        const sel = document.getElementById('alvo');
        if (sel && id) {
          Array.from(sel.options).forEach(o => { if (String(o.value) === String(id)) o.remove(); });
        }
      } catch(_) {}
    }
    function removeFromAcoesDe(id){
      if (!IS_GM || !id) return;
      try {
        const sel = document.getElementById('personagem_acao');
        if (!sel) return;
        Array.from(sel.options).forEach(o => { if (String(o.value) === String(id)) o.remove(); });
      } catch(_) {}
    }
    // Limpa id removido de seleções persistidas (targets) em localStorage
    function purgeTargetFromStorage(remId){
      if (!remId) return;
      try {
        const prefix = `combate:${combateId}:targets:`;
        // Percorre snapshot das keys porque alterar localStorage durante iteração direta pode pular entradas
        const keys = [];
        for (let i=0;i<localStorage.length;i++) { const k = localStorage.key(i); if (k && k.startsWith(prefix)) keys.push(k); }
        keys.forEach(k => {
          try {
            const raw = localStorage.getItem(k);
            if (!raw) return;
            const arr = JSON.parse(raw);
            if (Array.isArray(arr)) {
              const filtered = arr.filter(v => String(v) !== String(remId));
              if (filtered.length !== arr.length) localStorage.setItem(k, JSON.stringify(filtered));
            }
          } catch(_) {}
        });
      } catch(_) {}
    }

    // ====== AJAXify de formulários para evitar reload ======
    function bindAjax(form){
      if (!form || form.dataset.ajaxified === '1') return;
      form.addEventListener('submit', function(e){
        e.preventDefault();
        const submitter = e.submitter || null;
        // Garante que os campos hidden do atacante reflitam o valor atual de "Ações de"
        try {
          const selAtacante = document.getElementById('personagem_acao');
          const val = selAtacante ? selAtacante.value : '';
          ['personagem_acao_hidden','personagem_acao_hidden_pericia','personagem_acao_hidden_caracteristica','personagem_acao_hidden_d20']
            .forEach(id => { const h = document.getElementById(id); if (h) h.value = val; });
        } catch(_) {}
        // Captura contexto da origem do poder selecionado (para anotar no histórico pós-envio)
        try {
          const poderSel = form.querySelector('#poder');
          const opt = poderSel ? poderSel.options[poderSel.selectedIndex] : null;
          window._lastSubmitItemOrigem = opt ? (opt.dataset.itemOrigem || '') : '';
          window._lastSubmitPoderNome = opt ? (opt.textContent || '').replace(/\s*—\s*item:.*$/, '') : '';
        } catch(_) { window._lastSubmitItemOrigem=''; window._lastSubmitPoderNome=''; }
        let fd;
        try { fd = new FormData(form, submitter); }
        catch(_){ fd = new FormData(form); if (submitter && submitter.name) fd.append(submitter.name, submitter.value || '1'); }
        const btn = submitter || form.querySelector('button[type="submit"]');
        if (btn) btn.disabled = true;
        // Se poder descritivo estiver selecionado, assegura que nenhum campo alvo bloqueie o envio
        try {
          const poderSel = form.querySelector('#poder');
          const alvoSel = form.querySelector('#alvo');
          const opt = poderSel ? poderSel.options[poderSel.selectedIndex] : null;
          const tipo = opt ? (opt.dataset.tipo || '') : '';
          if (tipo === 'descritivo' && alvoSel) {
            alvoSel.disabled = true; // evita validação nativa
          }
        } catch(_) {}
        fetch(form.action, {
          method: 'POST',
          body: fd,
          headers: { 'X-Requested-With': 'XMLHttpRequest', 'Accept': 'application/json' },
          credentials: 'same-origin'
        }).then(async (resp) => {
          const ct = (resp.headers.get('content-type') || '').toLowerCase();
          let data = null;
          if (ct.includes('application/json')) { try { data = await resp.json(); } catch(_) {} }
          if (!resp.ok) throw new Error('request_failed');
          // Prefer targeted updates when possible; otherwise, generic refresh
          if (data && data.evento) {
            switch (data.evento) {
              case 'rolagem':
                await refreshSelectors(['#historico-card', '#status-card']);
                // Anota origem do item no último registro, quando conhecida
                try {
                  const origem = (window._lastSubmitItemOrigem || '').trim();
                  if (origem) {
                    const bloco = document.querySelector('.turnos-list .turno-item.ativo .turno-desc') || document.querySelector('.turnos-list .turno-item:first-child .turno-desc');
                    if (bloco) {
                      // Procura primeira linha de ação e acrescenta a origem
                      const firstLine = bloco.querySelector('.hist-acao');
                      if (firstLine && !firstLine.querySelector('.hist-item-origem')) {
                        const span = document.createElement('span');
                        span.className = 'hist-item-origem';
                        span.style.opacity = '0.85';
                        span.style.marginLeft = '6px';
                        span.textContent = '(Item: ' + origem + ')';
                        firstLine.appendChild(span);
                      }
                    }
                  }
                } catch(_) {}
                break;
              case 'adicionar_participante':
                // Atualização incremental sem recriar form completo
                if (data.participante) {
                  try { console.debug('[AJAX][adicionar_participante] id=', data.participante.id); } catch(_) {}
                  ensureAlvoHasParticipant(data.participante);
                  maybeAddToAcoesDe(data.participante);
                }
                // Atualiza apenas coluna direita/status (evita sobrescrever seleção/poderes)
                // Skip refreshing combate-col-right to preserve drawings
                await refreshSelectors(['#status-card']);
                // Verificação tardia apenas injeta opção se ausente (sem refresh do form)
                try {
                  const newId = data.participante && data.participante.id;
                  if (newId) {
                    setTimeout(() => {
                      try {
                        const alvoSel = document.getElementById('alvo');
                        const exists = alvoSel && Array.from(alvoSel.options).some(o => String(o.value) === String(newId));
                        if (!exists) {
                          console.debug('[AJAX][adicionar_participante] re-inserindo opção ausente', newId);
                          ensureAlvoHasParticipant(data.participante);
                        }
                      } catch(_) {}
                    }, 600);
                  }
                } catch(_) {}
                break;
              case 'remover_participante':
                if (data.participante_id) {
                  try { console.debug('[AJAX][remover_participante] participante_id=', data.participante_id); } catch(_) {}
                  removeFromAlvo(data.participante_id);
                  removeFromAcoesDe(data.participante_id);
                  purgeTargetFromStorage(data.participante_id);
                  // Se atacante selecionado foi removido, troca para primeiro
                  try {
                    const sel = document.getElementById('personagem_acao');
                    if (sel && String(sel.value) === String(data.participante_id)) {
                      if (sel.options.length) { sel.selectedIndex = 0; sel.dispatchEvent(new Event('change')); }
                    }
                  } catch(_) {}
                }
                // Skip refreshing combate-col-right to preserve drawings
                await refreshSelectors(['#status-card']);
                // Verificação tardia remove opção persistente sem recriar form
                try {
                  const remId = data.participante_id;
                  if (remId) {
                    setTimeout(() => {
                      try {
                        const alvoSel = document.getElementById('alvo');
                        const still = alvoSel && Array.from(alvoSel.options).some(o => String(o.value) === String(remId));
                        if (still) {
                          console.debug('[AJAX][remover_participante] re-removendo opção persistente', remId);
                          removeFromAlvo(remId);
                        }
                      } catch(_) {}
                    }, 600);
                  }
                } catch(_) {}
                break;
              case 'iniciar_turno':
              case 'avancar_turno':
              case 'finalizar_combate':
                await refreshSelectors(['.turno-topbar', '#historico-card', '#status-card']);
                break;
              case 'concentracao_tick': {
                // Após ticks de efeitos, sempre forçar atualização do status pois dano/aflição podem mudar múltiplas vezes
                await refreshSelectors(['#historico-card', '#status-card']);
                break;
              }
              case 'adicionar_mapa':
              case 'remover_mapa':
                // Skip refreshing combate-col-right to preserve drawings
                await refreshSelectors([]);
                break;
              case 'limpar_historico':
                // Não toque no form de ataque; só limpa topbar e histórico
                await refreshSelectors(['.turno-topbar', '#historico-card']);
                break;
              default:
                await refreshSelectors(['.turno-topbar', '#historico-card', '.combate-col-right']);
            }
          } else {
            await refreshSelectors(['.turno-topbar', '#historico-card', '.combate-col-right']);
          }
        }).catch(async () => {
          // Generic fallback on error
          try { await refreshSelectors(['.turno-topbar', '#historico-card', '.combate-col-right']); } catch(_) {}
        }).finally(() => {
          if (btn) btn.disabled = false;
          // Reativa alvo após envio
          try { const alvoSel = form.querySelector('#alvo'); if (alvoSel) alvoSel.disabled = false; } catch(_) {}
        });
      });
      form.dataset.ajaxified = '1';
    }
    function ajaxifyInteractionForms(){
      bindAjax(document.getElementById('form-d20'));
  bindAjax(document.getElementById('form-ataque'));
  bindAjax(document.getElementById('form-mapa'));
      document.querySelectorAll('.turno-topbar-actions form').forEach(bindAjax);
  document.querySelectorAll('.form-remover-participante').forEach(bindAjax);
  document.querySelectorAll('.form-add-participante').forEach(bindAjax);
    document.querySelectorAll('.form-limpar-historico').forEach(bindAjax);
  document.querySelectorAll('.mapa-remover-form').forEach(bindAjax);
  bindAjax(document.getElementById('form-encerrar-meus'));
  // Bind dos novos formulários de ações de participantes
  document.querySelectorAll('.form-acao-participante').forEach(bindAjax);
    }

    combateSocket.onmessage = async function(e) {
  lastEventAt = Date.now();
      let payload = null;
      try { payload = JSON.parse(e.data); } catch(_) {}
      if (!payload || !payload.evento) {
        // Desconhecido: faça refresh leve dos principais blocos
  await refreshSelectors(['.turno-topbar', '#historico-card', '#status-card']);
        return;
      }
      switch (payload.evento) {
        case 'token_move': {
          // Atualiza apenas o token informado, sem refresh de colunas
          const id = payload.posicao_id;
          const x = payload.x; const y = payload.y;
          const mapa_id = payload.mapa_id;
          const tokenId = 'token-' + id;
          const token = document.getElementById(tokenId);
          console.log('[WS] token_move:', { id, mapa_id, x, y, tokenId, tokenFound: !!token });
          if (token && Number.isFinite(x) && Number.isFinite(y)) {
            token.style.left = x + 'px';
            token.style.top = y + 'px';
            console.log('[WS] token_move: movido para', x, y);
          } else {
            console.warn('[WS] token_move: token não encontrado ou coordenadas inválidas', { id, x, y, token: !!token });
          }
          break;
        }
        case 'token_resize': {
          const id = payload.posicao_id;
          const size = payload.size;
          const token = document.getElementById('token-' + id);
          console.log('[WS] token_resize:', { id, size, tokenFound: !!token });
          if (token && Number.isFinite(size)) {
            token.style.width = size + 'px';
            token.style.height = size + 'px';
            console.log('[WS] token_resize: redimensionado para', size);
          }
          try { persistTokenSize(token); } catch(_) {}
          break;
        }
        case 'rolagem': {
          // Acrescenta somente ao histórico
          const ativo = document.querySelector('.turnos-list .turno-item.ativo .turno-desc')
                        || document.querySelector('.turnos-list .turno-item:first-child .turno-desc');
          if (ativo) {
            // Detecta se usuário estava perto do final antes de inserir novo conteúdo
            const historicoBefore = document.getElementById('historico-card');
            let wasNearBottom = false;
            try {
              if (historicoBefore) {
                wasNearBottom = (historicoBefore.scrollHeight - historicoBefore.scrollTop - historicoBefore.clientHeight) < 24;
              }
            } catch(_) {}
            const extra = document.createElement('div');
            extra.innerHTML = payload.descricao || '';
            // Preserva quebras de linha como HTML
            if (ativo.dataset.rawHtml) {
              ativo.dataset.rawHtml = (ativo.dataset.rawHtml ? ativo.dataset.rawHtml + '<br>' : '') + (payload.descricao || '');
              ativo.innerHTML = ativo.dataset.rawHtml;
              // Reaplica enhance somente para este bloco
              try { enhanceHistorico(ativo.parentElement); } catch(_) {}
            } else {
              ativo.innerHTML = (ativo.innerHTML ? ativo.innerHTML + '<br>' : '') + extra.innerHTML;
              try { enhanceHistorico(ativo.parentElement); } catch(_) {}
            }
            // Só rola para o fim se o usuário já estava perto do fim
            const historico = document.getElementById('historico-card');
            if (wasNearBottom && historico && historico.scrollHeight > historico.clientHeight) {
              historico.scrollTop = historico.scrollHeight;
            }
            // Se o evento WS informar a origem do item, anota na primeira linha recém-formatada
            try {
              const origemWs = (payload && (payload.item_origem_nome || payload.item_origem || payload.origem_item || '')) || '';
              if (origemWs) {
                const firstLine = ativo.querySelector('.hist-acao');
                if (firstLine && !firstLine.querySelector('.hist-item-origem')) {
                  const span = document.createElement('span');
                  span.className = 'hist-item-origem';
                  span.style.opacity = '0.85';
                  span.style.marginLeft = '6px';
                  span.textContent = '(Item: ' + origemWs + ')';
                  firstLine.appendChild(span);
                }
              }
            } catch(_) {}
            // Garante atualização do status dos participantes sem recarregar a página inteira
            await refreshSelectors(['#status-card']);
          } else {
            await refreshSelectors(['#historico-card', '#status-card']);
          }
          break;
        }
        case 'draw': {
          applyRemoteDraw(payload);
          break;
        }
        case 'draw_snapshot': {
          // Recebe snapshot PNG completo via WebSocket e atualiza canvas
          console.log('[WS] draw_snapshot recebido:', payload);
          const mapaId = payload.mapa_id;
          const snapshotData = payload.snapshot;
          if (!mapaId || !snapshotData) {
            console.warn('[WS] draw_snapshot sem mapa_id ou snapshot:', payload);
            break;
          }
          const area = document.getElementById('mapa-area-' + mapaId);
          if (!area) {
            console.warn('[WS] draw_snapshot: área não encontrada para mapa', mapaId);
            break;
          }
          const canvas = area.querySelector('.mapa-draw-layer');
          if (!canvas) {
            console.warn('[WS] draw_snapshot: canvas não encontrado para mapa', mapaId);
            if (window.ensureDrawLayersAll) window.ensureDrawLayersAll();
            const canvas2 = area.querySelector('.mapa-draw-layer');
            if (!canvas2) {
              console.error('[WS] draw_snapshot: canvas ainda não existe após ensureDrawLayersAll');
              break;
            }
            const ctx2 = canvas2.getContext('2d');
            const img2 = new Image();
            img2.onload = () => {
              console.log('[WS] draw_snapshot: imagem carregada (fallback)', canvas2.width, 'x', canvas2.height);
              ctx2.clearRect(0, 0, canvas2.width, canvas2.height);
              ctx2.drawImage(img2, 0, 0, canvas2.width, canvas2.height);
            };
            img2.onerror = (e) => console.error('[WS] draw_snapshot: erro ao carregar imagem', e);
            img2.src = snapshotData;
            break;
          }
          const ctx = canvas.getContext('2d');
          const img = new Image();
          img.onload = () => {
            console.log('[WS] draw_snapshot: imagem carregada', canvas.width, 'x', canvas.height);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
          };
          img.onerror = (e) => console.error('[WS] draw_snapshot: erro ao carregar imagem', e);
          img.src = snapshotData;
          break;
        }
        case 'clear_drawings': {
          const mapaId = payload.mapa_id;
          console.log('[WS] clear_drawings recebido:', { mapaId });
          if (!mapaId) {
            console.warn('[WS] clear_drawings: mapa_id ausente');
            break;
          }
          const area = document.getElementById('mapa-area-' + mapaId);
          if (!area) {
            console.warn('[WS] clear_drawings: área não encontrada para mapa', mapaId);
            break;
          }
          const canvas = area.querySelector('.mapa-draw-layer');
          if (!canvas) {
            console.warn('[WS] clear_drawings: canvas não encontrado para mapa', mapaId);
            break;
          }
          const ctx = canvas.getContext('2d');
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          console.log('[WS] clear_drawings: canvas limpo para mapa', mapaId);
          break;
        }
        case 'limpar_historico': {
          await refreshSelectors(['.turno-topbar', '#historico-card', '#form-ataque']);
          break;
        }
  case 'adicionar_mapa':
  case 'remover_mapa': {
          await refreshSelectors(['.combate-col-right']);
          break;
        }
        case 'adicionar_participante': {
          // Atualização incremental (sem recriar form inteiro)
          ensureAlvoHasParticipant(payload && payload.participante);
          maybeAddToAcoesDe(payload && payload.participante);
          await refreshSelectors(['.combate-col-right']);
          // Atualiza tokens no mapa para refletir novo participante
          if (window.ensureAllAreasMinScale) window.ensureAllAreasMinScale();
          try {
            const newId = payload && payload.participante && payload.participante.id;
            if (newId) {
              setTimeout(() => {
                try {
                  const alvoSel = document.getElementById('alvo');
                  const exists = alvoSel && Array.from(alvoSel.options).some(o => String(o.value) === String(newId));
                  if (!exists) {
                    console.debug('[WS][adicionar_participante] re-inserindo opção ausente', newId);
                    ensureAlvoHasParticipant(payload.participante);
                  }
                } catch(_) {}
              }, 600);
            }
          } catch(_) {}
          break;
        }
        case 'remover_participante': {
          const remId = payload && payload.participante_id;
          // Remove token visualmente do mapa imediatamente
          if (remId) {
            const token = document.getElementById('token-' + remId);
            if (token) {
              token.remove();
              console.log('[WS][remover_participante] token removido visualmente:', remId);
            }
          }
          removeFromAlvo(remId);
          removeFromAcoesDe(remId);
          purgeTargetFromStorage(remId);
          // Se atacante atual foi removido, seleciona primeiro restante
          try {
            const sel = document.getElementById('personagem_acao');
            if (sel && remId && String(sel.value) === String(remId) && sel.options.length) {
              sel.selectedIndex = 0; sel.dispatchEvent(new Event('change'));
            }
          } catch(_) {}
          await refreshSelectors(['.combate-col-right']);
          try {
            if (remId) {
              setTimeout(() => {
                try {
                  const alvoSel = document.getElementById('alvo');
                  const still = alvoSel && Array.from(alvoSel.options).some(o => String(o.value) === String(remId));
                  if (still) {
                    console.debug('[WS][remover_participante] re-removendo opção persistente', remId);
                    removeFromAlvo(remId);
                  }
                } catch(_) {}
              }, 600);
            }
          } catch(_) {}
          break;
        }
        case 'iniciar_turno':
        case 'avancar_turno': {
          // Update active turn name immediately if server provided it
          try {
            const nm = payload && payload.display_nome;
            if (nm) {
              const el = document.getElementById('turno-ativo-nome');
              if (el) el.textContent = nm;
            }
          } catch(_) {}
          try { window._lastTurnDisplayNome = payload && payload.display_nome; } catch(_) {}
          await refreshSelectors(['.turno-topbar', '#historico-card', '#status-card']);
          break;
        }
        case 'finalizar_combate': {
          await refreshSelectors(['.turno-topbar', '#historico-card', '#status-card']);
          break;
        }
        case 'status_atualizado': {
          // Atualiza apenas o status dos participantes quando há ações rápidas (buff/debuff/aflição/etc)
          await refreshSelectors(['#status-card', '#historico-card']);
          break;
        }
        default: {
          // Evento desconhecido: evita recarregar o mapa; atualiza cabeçalho, histórico e status
          await refreshSelectors(['.turno-topbar', '#historico-card', '#status-card']);
        }
      }
    };

    window._combateWsActive = false;
    combateSocket.onopen = function(){ 
      window._combateWsActive = true; 
      stopCombatePolling(); 
      console.log('WebSocket conectado');
    };
    combateSocket.onclose = function(e) {
      window._combateWsActive = false;
      console.warn('WebSocket fechado (code:', e.code, '). Polling ativado.');
      startCombatePolling();
    };
    combateSocket.onerror = function(err){
      window._combateWsActive = false;
      console.error('WebSocket erro:', err);
    };
  startHeartbeat();

    window.enviarMensagemCombate = function(msg) {
      combateSocket.send(msg);
    };

    // ====== Equalização de alturas (Mapa x Ações) e (Histórico x Status) ======
    function equalizarAlturas() {
      const isStacked = window.matchMedia('(max-width: 1000px)').matches;
      const acoesCard = document.getElementById('form-ataque');
      const acaoTopRow = document.querySelector('.acao-top-row');
      const mapaAreas = document.querySelectorAll('.mapa-area');
  const historicoCard = document.getElementById('historico-card');
  const statusCard = document.getElementById('status-card');
  // Removido: não sincronizamos mais a altura do histórico com o status para evitar "piscadas"

      const outerH = (el) => {
        if (!el) return 0;
        const cs = getComputedStyle(el);
        return el.offsetHeight + parseFloat(cs.marginTop || 0) + parseFloat(cs.marginBottom || 0);
      };

      // Reset when stacked
      if (isStacked) {
        mapaAreas.forEach(m => m.style.height = '');
        if (historicoCard) { historicoCard.style.height = ''; historicoCard.style.maxHeight = ''; historicoCard.style.overflowY = ''; }
        return;
      }

      // Mapa do Combate = altura do bloco de Ações (linha do topo + card), incluindo margens
      if (mapaAreas.length) {
        const alvoAlt = outerH(acaoTopRow) + outerH(acoesCard);
        mapaAreas.forEach(m => m.style.height = Math.max(600, alvoAlt) + 'px');
      }

  // Histórico: altura controlada por CSS (max-height), não ajustamos mais por JS.
    }

    // Run on load and resize (debounced)
    function rafEqualize(){ cancelAnimationFrame(rafEqualize._id||0); rafEqualize._id = requestAnimationFrame(equalizarAlturas); }
    window.addEventListener('resize', rafEqualize);
    // Wait a tick for layout
  setTimeout(equalizarAlturas, 50);
  setTimeout(equalizarAlturas, 250);
  // Após equalizar, garanta que a imagem cubra a área
  setTimeout(ensureAllAreasMinScale, 260);
    // E garante scroll ao fundo mesmo em telas pequenas, se houver overflow
    const historicoCardInit = document.getElementById('historico-card');
    if (historicoCardInit) {
  // Não force autoscroll inicial; preserve posição do usuário
    }
    // Also after images load
    document.querySelectorAll('.mapa-img').forEach(img => {
      if (img.complete) {
        ensureAllAreasMinScale();
        return;
      }
      img.addEventListener('load', function(){ rafEqualize(); ensureAllAreasMinScale(); });
    });
  // Inicializa controles e grade
  setupGridControls();
  updateAllGrids();
  ensureAllAreasMinScale();
  try { restoreTokenSizes(document); } catch(_) {}
  // Formata histórico ao carregar
  try { enhanceHistorico(document); } catch(_) {}

    // ====== Ações do topo: selecionar/usar/adicionar mapa ======
    function setupTopbarMapActions(){
      const formMapa = document.getElementById('form-mapa');
      const selectMapaTop = document.getElementById('mapa_existente_top');
      if (!(formMapa && selectMapaTop)) return;
      // Garante campo hidden no form real
      let hidden = formMapa.querySelector('#mapa_existente_hidden');
      if (!hidden) {
        hidden = document.createElement('input');
        hidden.type = 'hidden';
        hidden.name = 'mapa_existente';
        hidden.id = 'mapa_existente_hidden';
        formMapa.prepend(hidden);
      }

      const btnUsar = document.getElementById('btn-usar-mapa');
      function syncSelectToForm() { hidden.value = selectMapaTop.value || ''; }
      if (btnUsar) {
        // Remove listeners anteriores clonando o nó
        const clone = btnUsar.cloneNode(true);
        btnUsar.parentNode.replaceChild(clone, btnUsar);
        clone.addEventListener('click', function() {
          syncSelectToForm();
          if (!hidden.value) { alert('Selecione um mapa existente.'); return; }
          let flag = formMapa.querySelector('input[name="usar_existente"]');
          if (!flag) { flag = document.createElement('input'); flag.type = 'hidden'; flag.name = 'usar_existente'; flag.value = '1'; formMapa.appendChild(flag); }
          formMapa.submit();
        });
      }
    }

  document.addEventListener("DOMContentLoaded", function() {
    // Setup top bar map actions (must be after DOM is ready)
    setupTopbarMapActions();
    
    document.querySelectorAll("[id^='mapa-area-']").forEach(function(mapaArea) {
      mapaArea.addEventListener("dragover", function(e) { e.preventDefault(); });
      mapaArea.addEventListener("drop", function(e) {
        e.preventDefault();
        const tokenId = e.dataTransfer.getData("tokenId");
  const canvas = mapaArea.querySelector('.mapa-canvas') || mapaArea;
  const rect = canvas.getBoundingClientRect();
        const scale = parseFloat(mapaArea.dataset.scale || '1');
        const tokenEl = document.getElementById('token-' + tokenId);
        const tokenSize = tokenEl ? parseFloat(getComputedStyle(tokenEl).width) || 40 : 40;
        const half = tokenSize / 2;
        let x = (e.clientX - rect.left - half) / scale;
        let y = (e.clientY - rect.top - half) / scale;
        // Clamp to image bounds
        const img = canvas.querySelector('.mapa-img');
        const baseW = img ? (img.naturalWidth || img.clientWidth) : 0;
        const baseH = img ? (img.naturalHeight || img.clientHeight) : 0;
        if (baseW && baseH) {
          x = Math.max(0, Math.min(baseW - tokenSize, x));
          y = Math.max(0, Math.min(baseH - tokenSize, y));
        }
  if (window.gridEnabled && window.gridEnabled()) { const snapped = window.applyGridSnap ? window.applyGridSnap(x, y) : {x, y}; x = snapped.x; y = snapped.y; }
        fetch(`/combate/atualizar-posicao-token/${tokenId}/`, {
          method: "POST",
          headers: {
            "X-CSRFToken": "{{ csrf_token }}",
            "Content-Type": "application/json"
          },
          credentials: 'same-origin',
          body: JSON.stringify({x, y})
        }).then(() => {
          const token = document.getElementById("token-" + tokenId);
          token.style.left = x + "px";
          token.style.top = y + "px";
        });
      });
      // Bind per-token Ctrl+wheel resize on initial load as well
      mapaArea.querySelectorAll('.mapa-token').forEach(token => {
        if (token.dataset.wheelResized) return;
        token.addEventListener('wheel', function(e){
          if (!e.ctrlKey) return;
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();
          const cs = getComputedStyle(token);
          const cur = parseFloat(cs.width) || 40;
          const dir = e.deltaY > 0 ? -1 : 1;
          const factor = dir > 0 ? 1.1 : 1/1.1;
          let next = +(cur * factor).toFixed(2);
          const min = 20, max = 120;
          next = Math.max(min, Math.min(max, next));
          token.style.width = next + 'px';
          token.style.height = next + 'px';
          try { persistTokenSize(token); } catch(_) {}
          try {
            const id = (token.id || '').replace('token-','');
            fetch(`/combate/atualizar-posicao-token/${id}/`, {
              method: 'POST',
              headers: { 'X-CSRFToken': '{{ csrf_token }}', 'Content-Type': 'application/json' },
              credentials: 'same-origin',
              body: JSON.stringify({ size: next })
            }).catch(()=>{});
          } catch(_) {}
        }, { passive: false });
        token.dataset.wheelResized = '1';
        try { restoreTokenSize(token); } catch(_) {}
      });
      // Initialize zoom controls on DOMContentLoaded as well (outside scroll area)
      const wrapper = mapaArea.closest('.mapa-wrapper') || mapaArea.parentElement;
      const zoomBar = wrapper ? wrapper.querySelector('.mapa-zoom') : null;
      const canvas = mapaArea.querySelector('.mapa-canvas');
      if (zoomBar && canvas) {
        zoomBar.querySelectorAll('button[data-zoom]').forEach(btn => {
          // Remove previous listeners by cloning (initial load safe too)
          const cloned = btn.cloneNode(true);
          btn.replaceWith(cloned);
          cloned.addEventListener('click', function(){
            const action = this.getAttribute('data-zoom');
            let scale = parseFloat(mapaArea.dataset.scale || '1');
            if (action === 'in') scale = +(scale * 1.1).toFixed(3);
            else if (action === 'out') scale = +(scale / 1.1).toFixed(3);
            else scale = 1;
            // Use the main setScale function
            setScale(scale);
          });
        });
      }
      // Panning bind on initial load as well
      (function bindPanInit(){
        if (!window._mapPanKeyBound) {
          window._mapSpacePressed = false;
          window.addEventListener('keydown', (ev)=>{ if (ev.code === 'Space') { window._mapSpacePressed = true; ev.preventDefault(); } }, { capture:true });
          window.addEventListener('keyup', (ev)=>{ if (ev.code === 'Space') { window._mapSpacePressed = false; ev.preventDefault(); } }, { capture:true });
          window._mapPanKeyBound = true;
        }
        if (!mapaArea.dataset.panBound) {
          let panning = false, startX = 0, startY = 0, startL = 0, startT = 0;
          function clampScrollToBounds() {
            const canvas = mapaArea.querySelector('.mapa-canvas');
            const img = canvas ? canvas.querySelector('.mapa-img') : null;
            if (!img) return;
            const scale = parseFloat(mapaArea.dataset.scale || '1');
            const baseW = img.naturalWidth || img.clientWidth || 0;
            const baseH = img.naturalHeight || img.clientHeight || 0;
            const maxX = Math.max(0, baseW * scale - mapaArea.clientWidth);
            const maxY = Math.max(0, baseH * scale - mapaArea.clientHeight);
            if (mapaArea.scrollLeft > maxX) mapaArea.scrollLeft = maxX;
            if (mapaArea.scrollTop > maxY) mapaArea.scrollTop = maxY;
            if (mapaArea.scrollLeft < 0) mapaArea.scrollLeft = 0;
            if (mapaArea.scrollTop < 0) mapaArea.scrollTop = 0;
          }
          function onMove(ev){ if (!panning) return; const dx = ev.clientX - startX; const dy = ev.clientY - startY; mapaArea.scrollLeft = startL - dx; mapaArea.scrollTop = startT - dy; clampScrollToBounds(); }
          function endPan(){ if (!panning) return; panning = false; mapaArea.classList.remove('panning'); window.removeEventListener('mousemove', onMove, true); window.removeEventListener('mouseup', endPan, true); }
          mapaArea.addEventListener('mousedown', function(ev){ const isMiddle = ev.button === 1; const isSpaceDrag = ev.button === 0 && window._mapSpacePressed; if (!isMiddle && !isSpaceDrag) return; ev.preventDefault(); ev.stopPropagation(); panning = true; startX = ev.clientX; startY = ev.clientY; startL = mapaArea.scrollLeft; startT = mapaArea.scrollTop; mapaArea.classList.add('panning'); window.addEventListener('mousemove', onMove, true); window.addEventListener('mouseup', endPan, true); }, { capture:true });
          mapaArea.addEventListener('mousedown', function(ev){ if (mapaArea.dataset.drawing === '1') { ev.stopPropagation(); return; } }, { capture:true });
          mapaArea.addEventListener('dragstart', function(ev){ if (window._mapSpacePressed) { ev.preventDefault(); ev.stopImmediatePropagation(); } }, true);
          mapaArea.dataset.panBound = '1';
        }
      })();

      // Wheel handler on initial bind as well
      if (!mapaArea.dataset.wheelBound) {
        mapaArea.addEventListener('wheel', function(e){
          if (!e.ctrlKey) return;
          e.preventDefault();
          const canvas = mapaArea.querySelector('.mapa-canvas');
          if (!canvas) return;
          let scale = parseFloat(mapaArea.dataset.scale || '1');
          const dir = e.deltaY > 0 ? -1 : 1;
          const factor = dir > 0 ? 1.1 : 1/1.1;
          scale = +(scale * factor).toFixed(3);
          const img = canvas.querySelector('.mapa-img');
          const baseW = img.naturalWidth || img.clientWidth;
          const baseH = img.naturalHeight || img.clientHeight;
          const areaW = mapaArea.clientWidth || 1;
          const areaH = mapaArea.clientHeight || 1;
          const fitW = areaW / (baseW || areaW);
          const fitH = areaH / (baseH || areaH);
          // Ao fazer zoom com a roda, mantenha a escala mínima permitindo upscaling
          const minScale = Math.max(fitW, fitH);
          const maxScale = 3;
          const oldScale = parseFloat(mapaArea.dataset.scale || '1');
          // Clamp scale to dynamic bounds
          scale = Math.max(minScale, Math.min(maxScale, scale));
          const areaRect = mapaArea.getBoundingClientRect();
          const pointerX = e.clientX - areaRect.left;
          const pointerY = e.clientY - areaRect.top;
          canvas.style.transform = `scale(${scale})`;
          canvas.style.minWidth = (baseW * scale) + 'px';
          canvas.style.minHeight = (baseH * scale) + 'px';
          mapaArea.dataset.scale = String(scale);
          if (window.updateDrawLayerSizes) window.updateDrawLayerSizes();
          const sx = mapaArea.scrollLeft;
          const sy = mapaArea.scrollTop;
          const nx = (sx + pointerX) * (scale / oldScale) - pointerX;
          const ny = (sy + pointerY) * (scale / oldScale) - pointerY;
          const maxScrollX = Math.max(0, mapaArea.scrollWidth - mapaArea.clientWidth);
          const maxScrollY = Math.max(0, mapaArea.scrollHeight - mapaArea.clientHeight);
          mapaArea.scrollLeft = Math.min(maxScrollX, Math.max(0, nx));
          mapaArea.scrollTop = Math.min(maxScrollY, Math.max(0, ny));
        }, { passive: false });
        mapaArea.dataset.wheelBound = '1';
      }
      // Clamp scroll on initial load as well
      if (!mapaArea.dataset.scrollBound) {
        mapaArea.addEventListener('scroll', function(){
          const canvas = mapaArea.querySelector('.mapa-canvas');
          const img = canvas ? canvas.querySelector('.mapa-img') : null;
          if (!img) return;
          const scale = parseFloat(mapaArea.dataset.scale || '1');
          const baseW = img.naturalWidth || img.clientWidth || 0;
          const baseH = img.naturalHeight || img.clientHeight || 0;
          const maxX = Math.max(0, baseW * scale - mapaArea.clientWidth);
          const maxY = Math.max(0, baseH * scale - mapaArea.clientHeight);
          if (mapaArea.scrollLeft > maxX) mapaArea.scrollLeft = maxX;
          if (mapaArea.scrollTop > maxY) mapaArea.scrollTop = maxY;
          if (mapaArea.scrollLeft < 0) mapaArea.scrollLeft = 0;
          if (mapaArea.scrollTop < 0) mapaArea.scrollTop = 0;
        }, { passive: true });
        mapaArea.dataset.scrollBound = '1';
      }
    });
  });
</script>

{% endblock %}

